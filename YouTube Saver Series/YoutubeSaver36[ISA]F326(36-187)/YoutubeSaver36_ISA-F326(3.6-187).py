# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'YoutubeSaver_ISA.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

from PyQt5 import QtCore, QtGui, QtWidgets
import shutil
import sys
import re
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QFileDialog, QWidget , QInputDialog , QLineEdit ,  QListWidget , QComboBox
import datetime
import winshell
from win32com.client import Dispatch 
from PySide2.QtCore import QTimer
from PySide2.QtWidgets import QApplication , QMessageBox
import os
import json
import time 
import zipfile
import wx
import pytube
import pytube.exceptions
from moviepy.video.io.VideoFileClip import VideoFileClip
import music_tag
'''Source files'''
cfile_path = os.path.realpath(__file__)

# Current working directory or the 'Now'-location of the file.
# cdir = os.path.dirname(cfile_path)

cdir = os.getcwd()

# Time
dt_clockH = datetime.datetime.now().strftime("%I")

dt_clockM = datetime.datetime.now().strftime("%M")

dt_clockS = datetime.datetime.now().strftime("%S")

dt_clockMS = datetime.datetime.now().strftime("%f")

epoch_miliseconds = int(time.time() * 1000)

dt_TMR = f"{dt_clockH}:{dt_clockM}:{dt_clockS}"

dt_time= f"{dt_clockH}:{dt_clockM}"

dt_DN = datetime.datetime.now().strftime('%p').lower()

# Date
dt_dd = datetime.datetime.now().strftime("%d")

dt_mm = datetime.datetime.now().strftime("%m")

dt_yyyy = datetime.datetime.now().strftime("%Y")

dt_wdys = datetime.datetime.now().strftime("%A").lower()

dt_mnths = datetime.datetime.now().strftime("%B")

dt_mnths_no = datetime.datetime.now().strftime("%m")

dt_date = f"{dt_dd}-{dt_mm}-{dt_yyyy}"

dt_mnthsno_mnths = f"{dt_mnths_no}-{dt_mnths}"

# App main folder
main_folder_name ='YouTube Saver 3.6 [I.S.A] downloads'

# Playlist Video folder maker datas
playlist_videos_folder_name = "Playlist Videos"

# Playlist Audio folder maker datas
playlist_audios_folder_name = "Playlist Audios"

# Audios folder maker datas
audios_folder_name = "Audios"

# Video folder maker datas
videos_folder_name = "Videos"

# settings json files
jsonfl_name = "36yt_dwnlds_paths"

root_json_fl = f"{jsonfl_name}.json"

paths_datas_json_file_path = os.path.join(cdir,root_json_fl) 

# App title
app_title = "YouTube Saver 3.6 [Improved.Simplified.Alternative]"

# App version
app_ver = "Finalized 326"

# Logs folder details
log_dirname = "Logs"
logs_folder_path = os.path.join(cdir,log_dirname)

# Log file details
logfl_name = f"Log_{dt_date}"
log_fl = f"{logfl_name}.log"

class Ui_MainWindow(QWidget):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(800, 600)

        # Set APP BG color
        self.palette = QtGui.QPalette()
        self.brush = QtGui.QBrush(QtGui.QColor(33, 192, 162))
        self.brush.setStyle(QtCore.Qt.SolidPattern)
        self.palette.setBrush(QtGui.QPalette.Window, self.brush)
        MainWindow.setPalette(self.palette)

        # Set app icon
        returned_icofl_path = self.icon_fls()
        MainWindow.setWindowIcon(QtGui.QIcon(returned_icofl_path))   

        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")

        self.Mainframe = QtWidgets.QFrame(self.centralwidget)
        self.Mainframe.setGeometry(QtCore.QRect(30, 20, 751, 531))
        self.Mainframe.setFrameShape(QtWidgets.QFrame.StyledPanel)
        self.Mainframe.setFrameShadow(QtWidgets.QFrame.Raised)
        self.Mainframe.setObjectName("Mainframe")

        self.link_input = QtWidgets.QLineEdit(self.Mainframe)
        self.link_input.setGeometry(QtCore.QRect(140, 70, 561, 71))

        font = QtGui.QFont()
        font.setPointSize(28)
        self.link_input.setFont(font)
        self.link_input.setToolTipDuration(-2)
        self.link_input.setStatusTip("")
        self.link_input.setObjectName("link_input")

        self.link_label = QtWidgets.QLabel(self.Mainframe)
        self.link_label.setGeometry(QtCore.QRect(40, 75, 91, 61))

        font = QtGui.QFont()
        font.setPointSize(28)
        self.link_label.setFont(font)
        self.link_label.setAlignment(QtCore.Qt.AlignCenter)
        self.link_label.setObjectName("link_label")

        self.qlabel = QtWidgets.QLabel()

        font = QtGui.QFont()
        font.setPointSize(16)
        self.res_combobox = QComboBox(self.Mainframe)
        self.res_combobox.addItem("720p")
        self.res_combobox.addItem("360p")
        self.res_combobox.setGeometry(QtCore.QRect(310, 161, 121, 51))
        self.res_combobox.setFont(font)
     
        self.Button_download_video = QtWidgets.QPushButton(self.Mainframe)
        self.Button_download_video.setGeometry(QtCore.QRect(70, 230, 181, 81))
        self.Button_download_video.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        font = QtGui.QFont()
        font.setPointSize(18)
        self.Button_download_video.setFont(font)
        self.Button_download_video.setObjectName("Button_download_video")

        self.Button_access = QtWidgets.QPushButton(self.Mainframe)
        self.Button_access.setGeometry(QtCore.QRect(281, 303, 181, 81))
        self.Button_access.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        font = QtGui.QFont()
        font.setPointSize(27)
        self.Button_access.setFont(font)
        self.Button_access.setObjectName("Button_accesss")

        self.Button_download_audio = QtWidgets.QPushButton(self.Mainframe)
        self.Button_download_audio.setGeometry(QtCore.QRect(490, 230, 181, 81))
        self.Button_download_audio.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        font = QtGui.QFont()
        font.setPointSize(18)
        self.Button_download_audio.setFont(font)
        self.Button_download_audio.setObjectName("Button_download_audio")

        self.Button_exit = QtWidgets.QPushButton(self.Mainframe)
        self.Button_exit.setGeometry(QtCore.QRect(70, 380, 181, 81))
        self.Button_exit.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        font = QtGui.QFont()
        font.setPointSize(27)
        self.Button_exit.setFont(font)
        self.Button_exit.setObjectName("Button_exit")

        self.Button_Reset = QtWidgets.QPushButton(self.Mainframe)
        self.Button_Reset.setGeometry(QtCore.QRect(490, 380, 181, 81))
        self.Button_Reset.setCursor(QtGui.QCursor(QtCore.Qt.PointingHandCursor))
        font = QtGui.QFont()    
        font.setPointSize(27)
        font.setBold(False)
        font.setWeight(50)
        self.Button_Reset.setFont(font)
        self.Button_Reset.setObjectName("Button_Reset")
 
        MainWindow.setCentralWidget(self.centralwidget)

        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 800, 23))
        self.menubar.setObjectName("menubar")

        self.menuOption = QtWidgets.QMenu(self.menubar)
        self.menuOption.setObjectName("menuOption")

        self.menuSettings = QtWidgets.QMenu(self.menuOption)
        self.menuSettings.setObjectName("menuSettings")
        MainWindow.setMenuBar(self.menubar)

        font = QtGui.QFont()
        font.setPointSize(24)
        font.setBold(True)
        font.setFamily("Arial")
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        self.statusbar.setFont(font)
        # self.statusbar.set
        MainWindow.setStatusBar(self.statusbar)

        self.menuOpen_Folders = QtWidgets.QMenu(MainWindow)
        self.menuOpen_Folders.setObjectName("menuOpen_Folders")

        self.actionChange_path = QtWidgets.QAction(MainWindow)
        self.actionChange_path.setObjectName("actionChange_path")

        self.actionOpen_LogFl = QtWidgets.QAction(MainWindow)
        self.actionOpen_LogFl.setObjectName("actionOpen_LogFl")

        self.actionOpen_app_dlfolder = QtWidgets.QAction(MainWindow)
        self.actionOpen_app_dlfolder.setObjectName("actionOpen_app_dlfolder")
        self.menuOpen_Folders.addAction(self.actionOpen_app_dlfolder)
        self.menuOpen_Folders.addSeparator()

        self.actionOpen_audios_folder = QtWidgets.QAction(MainWindow)
        self.actionOpen_audios_folder.setObjectName("actionOpen_audios_folder")
        self.menuOpen_Folders.addAction(self.actionOpen_audios_folder)
        self.menuOpen_Folders.addSeparator()

        self.actionOpen_videos_folder = QtWidgets.QAction(MainWindow)
        self.actionOpen_videos_folder.setObjectName("actionOpen_videos_folder")
        self.menuOpen_Folders.addAction(self.actionOpen_videos_folder)
        self.menuOpen_Folders.addSeparator()

        self.actionOpen_playlist_audios_folder = QtWidgets.QAction(MainWindow)
        self.actionOpen_playlist_audios_folder.setObjectName("actionOpen_playlist_audios_folder")
        self.menuOpen_Folders.addAction(self.actionOpen_playlist_audios_folder)
        self.menuOpen_Folders.addSeparator()

        self.actionOpen_playlist_videos_folder = QtWidgets.QAction(MainWindow)
        self.actionOpen_playlist_videos_folder.setObjectName("actionOpen_playlist_videos_folder")
        self.menuOpen_Folders.addAction(self.actionOpen_playlist_videos_folder)
        self.menuOpen_Folders.addSeparator()

        self.actionOpen_logs_folder = QtWidgets.QAction(MainWindow)
        self.actionOpen_logs_folder.setObjectName("actionOpen_logs_folder")
        self.menuOpen_Folders.addAction(self.actionOpen_logs_folder)
        self.menuOpen_Folders.addSeparator()

        self.menuSettings.addAction(self.actionChange_path)
        self.menuOption.addAction(self.menuSettings.menuAction())
        self.menuOption.addSeparator()
        self.menuOption.addAction(self.menuOpen_Folders.menuAction())
        self.menuOption.addSeparator()
        self.menuOption.addAction(self.actionOpen_LogFl)
        self.menubar.addAction(self.menuOption.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", app_title))
        
        # Set tooltip
        self.link_input.setToolTip(_translate("MainWindow", "Please place youtube url here"))

        # Set statustip
        self.Mainframe.setStatusTip(_translate("MainWindow",app_ver))
        
        self.Button_download_video.setStatusTip(_translate("MainWindow", "Click here to download youtube video. (Ctrl+Q)"))
            
        self.Button_access.setStatusTip(_translate("MainWindow","Click here to open 'Downloads folder'. (Ctrl+O)"))

        self.Button_download_audio.setStatusTip(_translate("MainWindow", "Click here to download youtube audio. (Ctrl+B)"))

        self.Button_Reset.setStatusTip(_translate("MainWindow", "Click here to reset. (Ctrl+Z)"))
        
        self.Button_exit.setStatusTip(_translate("MainWindow", "Click here to exit the app. (Press Esc)"))

        # link_label 
        self.link_label.setText(_translate("MainWindow", "Link:"))
        
        # Buttons
        self.Button_download_video.setText(_translate("MainWindow", "Download Video"))

        self.Button_access.setText(_translate("MainWindow","Access"))

        self.Button_download_audio.setText(_translate("MainWindow", "Download Audio"))

        self.Button_exit.setText(_translate("MainWindow", "Exit"))

        self.Button_Reset.setText(_translate("MainWindow", "Reset"))

        # Menu options
        self.menuOption.setTitle(_translate("MainWindow", "Options"))
        self.menuSettings.setTitle(_translate("MainWindow", "Settings"))
        self.menuOpen_Folders.setTitle(_translate("MainWindow", "Open app folders"))
        self.actionOpen_LogFl.setText(_translate("MainWindow", "Open log file"))
        self.actionChange_path.setText(_translate("MainWindow", "Change path"))
        self.actionOpen_app_dlfolder.setText(_translate("MainWindow","Open downloads folder"))
        self.actionOpen_audios_folder.setText(_translate("MainWindow",f"Open '{audios_folder_name}' folder"))
        self.actionOpen_videos_folder.setText(_translate("MainWindow",f"Open '{videos_folder_name}' folder"))
        self.actionOpen_playlist_audios_folder.setText(_translate("MainWindow",f"Open '{playlist_audios_folder_name}' folder"))
        self.actionOpen_playlist_videos_folder.setText(_translate("MainWindow",f"Open '{playlist_videos_folder_name}' folder"))
        self.actionOpen_logs_folder.setText(_translate("MainWindow",f"Open '{log_dirname}' folder"))
        
        # GUI Shortcuts
        self.actionOpen_app_dlfolder.setShortcut(_translate("MainWindow", "Ctrl+O"))

        self.actionChange_path.setShortcut(_translate("MainWindow", "Ctrl+P"))

        self.actionOpen_LogFl.setShortcut(_translate("MainWindow", "Ctrl+L"))
        
        self.Button_download_video.setShortcut(_translate("MainWindow", "Ctrl+Q"))

        self.Button_download_audio.setShortcut(_translate("MainWindow", "Ctrl+B"))

        self.Button_exit.setShortcut(_translate("MainWindow", "esc"))

        self.Button_Reset.setShortcut(_translate("MainWindow", "Ctrl+Z"))

        # Set status bar color

        # GUI Option connect event
        # -> Change path
        self.actionChange_path.triggered.connect(self.chngpath)

        self.actionOpen_LogFl.triggered.connect(self.open_logsfl)

        self.actionOpen_app_dlfolder.triggered.connect(self.open_app_dlsfolder)

        self.actionOpen_audios_folder.triggered.connect(self.open_app_audios_folder)
        self.actionOpen_videos_folder.triggered.connect(self.open_app_videos_folder)
            
        self.actionOpen_playlist_audios_folder.triggered.connect(self.open_app_playlist_audios_folder)
        self.actionOpen_playlist_videos_folder.triggered.connect(self.open_app_playlist_videos_folder)
        self.actionOpen_logs_folder.triggered.connect(self.open_logsfolder)

        # GUI Buton connect event
        # -> Download video button
        self.Button_download_video.clicked.connect(self.video_dl)

        # -> Access 'Download' folder
        self.Button_access.clicked.connect(self.open_app_dlsfolder)

        # -> Download audio button
        self.Button_download_audio.clicked.connect(self.audio_dl)

        # -> Exit button
        self.Button_exit.clicked.connect(self.exit)

        # -> Reset button
        self.Button_Reset.clicked.connect(self.reset)


        # GUI button colors 
        # -> Download video button
        self.Button_download_video.setStyleSheet("background-color : green; color: white")

        # -> Access 'Download' folder
        self.Button_access.setStyleSheet("background-color : blue; color: white")
        
        # -> Download audio button
        self.Button_download_audio.setStyleSheet("background-color : yellow; color: black")
        
        # -> Exit button
        self.Button_exit.setStyleSheet("background-color : red; color: white")

        # -> Reset button
        self.Button_Reset.setStyleSheet("background-color : purple; color: white")


        # GUI label colors 
        # -> url label
        self.link_label.setStyleSheet("background-color : brown; color: white")

        # GUI input box colors 
        # -> url input box
        self.link_input.setStyleSheet("color: brown")
    
    def read_json(self,jsonfl_path1,k1):
        with open(jsonfl_path1,'r') as pathjson_fl_r:
            data = pathjson_fl_r.read()

            infos_v = json.loads(data)[k1]

        return infos_v

    def save_json(self,json_flpath1,keys1,val1):

        infos = {
            keys1: str(val1)

                            }
        with open(json_flpath1,'w') as json_fl_w:
            json.dump(infos,json_fl_w)  

    def update_json(self,json_flpath3,keys3,info3,msg_txt3,msg_title3):

        with open(json_flpath3,'r') as json_data_r:
            json_src_data = json.load(json_data_r)

            json_src_data[keys3] = info3

            with open(json_flpath3,'w') as json_fl_w:
                json.dump(json_src_data,json_fl_w)

        self.msg_autoClose(msg_text=msg_txt3,msg_title=msg_title3,close_tmr=3,msg_icon=QMessageBox.Information)
    
    def save_path_json(self):
 
        if os.path.exists(paths_datas_json_file_path) == False:

            dir_dialog_title = f"Please choose folder (or directory) to hold '{main_folder_name}' folder:"
            dir_dlgbox = QFileDialog.getExistingDirectory(self, caption=dir_dialog_title)
           
            if dir_dlgbox:

                usr_rt_v = dir_dlgbox.replace("/","\\")

                self.save_json(json_flpath1=paths_datas_json_file_path,keys1="path",val1=usr_rt_v)
                
                self.msg_autoClose(msg_text="Path saved successfully.",msg_title="Path save - Complete:",close_tmr=3,msg_icon=QMessageBox.Information)

                #sys.exit()
            else:
                pass
        else:
            pass
      
    def apps_log_sys(self,logerr_msg,err_msgtitle,err_msgtxt):

        try:
            os.makedirs(logs_folder_path)
        except OSError:
            pass
        # logs_folder_path = os.path.join(logdirs6_path,log_dirname6)
        log_err = f"\n<{dt_date}\{dt_time}> , Error: {str(logerr_msg)}\n<________________________________________>\n"
        self.msg_autoClose(msg_text=f"Error cause: \n{str(err_msgtxt)}",msg_title=err_msgtitle,close_tmr=4,msg_icon=QMessageBox.Critical)

        logfl_path = os.path.join(logs_folder_path,log_fl)
        
        with open(logfl_path,"a", encoding="utf-8") as logfl_w6:
            logfl_w6.writelines(log_err)

    def msg_autoClose(self,msg_title,msg_text,close_tmr,msg_icon):

        qm = QMessageBox()
        qm.setIcon(msg_icon)
        qm.setWindowTitle(msg_title)
        qm.setText(msg_text+"                                                  ")
        qm.setStandardButtons(QMessageBox.Ok)
        QTimer.singleShot(close_tmr*1000,lambda : qm.done(0))
        qm.setFixedWidth(800+len(msg_text))
        qm.setFixedHeight(1755+len(msg_text))
        qm.exec_()

    def delay(self,var):
        time.sleep(var)

    def icon_fls(self):
        for file in os.listdir(cdir):
    
            # print(file)
            
            if '.ico' in file:
                try:
                    icon_flpath =os.path.join(cdir,file)
                    return icon_flpath
                except OSError:
                    pass
            else:
                pass

    def lists_box(self,l2,title2,txt2):

        app = wx.App()

        onechoice = wx.SingleChoiceDialog(None, txt2,title2, l2)

        oncechoice_out = onechoice.ShowModal()

        onechoice_item = onechoice.GetStringSelection()  

        return oncechoice_out , onechoice_item   

    def reset(self):
        self.link_input.clear()
        self.res_combobox.setCurrentText("720p")

    def chngpath(self):
        dir_dialog_title = f"Please choose folder (or directory) to be changed for '{main_folder_name}' folder:"
        
        chngdir_dlgbox = QFileDialog.getExistingDirectory(self, caption=dir_dialog_title)
           
        if chngdir_dlgbox:

            usr_chng_rt_v = chngdir_dlgbox.replace("/","\\")

            # print(usr_chng_rt_v)

            if os.path.exists(paths_datas_json_file_path)==True:

                self.update_json(json_flpath3=paths_datas_json_file_path,keys3="path",info3=usr_chng_rt_v,msg_title3="Path update - Complete:",msg_txt3="Path changed successfully.      ")

                self.get_json_paths()
            else:
                self.save_path_json()
        else:
            pass

    def get_json_paths(self):

        try:

            returned_path = self.read_json(jsonfl_path1=paths_datas_json_file_path,k1="path")

        # Main app folders ->

            # Main folder path
            appdl_folder_path = os.path.join(returned_path, main_folder_name)


        # Playlists Videos & Audios folders ->

            # playlist_video_folder
            playlist_videos_subfolder1_path = os.path.join(appdl_folder_path, playlist_videos_folder_name)

            # playlist_audio_folder
            playlist_audios_subfolder1_path = os.path.join(appdl_folder_path, playlist_audios_folder_name)

            # Current 'years' folder in 'Downloads' folder path
            crnt_yrs_subfolder2_path_playlist_videos = os.path.join(playlist_videos_subfolder1_path, dt_yyyy)

            # Current 'years' folder in 'Downloads' folder path
            crnt_yrs_subfolder2_path_playlist_audios = os.path.join(playlist_audios_subfolder1_path, dt_yyyy)

            # Current 'month number-month' folder in 'Playlist Videos' folder path
            crnt_mnthsno_mnths_subfolder3_path_playlist_videos = os.path.join(crnt_yrs_subfolder2_path_playlist_videos,dt_mnthsno_mnths)

            # Current 'month number-month' folder in 'Playlist Audios' folder path
            crnt_mnthsno_mnths_subfolder3_path_playlist_audios = os.path.join(crnt_yrs_subfolder2_path_playlist_audios,dt_mnthsno_mnths)

            # Current 'date' folder in Current month number-month folder from 'Playlist Videos' folder
            crnt_date_subfolder4_path_playlist_videos = os.path.join(crnt_mnthsno_mnths_subfolder3_path_playlist_videos,dt_date)

            # Current 'date' folder in Current month number-month folder from 'Playlist Videos' folder
            crnt_date_subfolder4_path_playlist_audios = os.path.join(crnt_mnthsno_mnths_subfolder3_path_playlist_audios,dt_date)


        # Videos & Audioa folders ->

            # Videos folder
            videos_subfolder1_path = os.path.join(appdl_folder_path, videos_folder_name)

            # Audios folder
            audios_subfolder1_path = os.path.join(appdl_folder_path, audios_folder_name)

            # Current 'years' folder in 'Videos' folder path
            crnt_yrs_subfolder2_path_videos = os.path.join(videos_subfolder1_path, dt_yyyy)

            # Current 'years' folder in 'Audios' folder path
            crnt_yrs_subfolder2_path_audios = os.path.join(audios_subfolder1_path, dt_yyyy)

            # Current 'month number-month' folder in 'Videos' folder path
            crnt_mnthsno_mnths_subfolder3_path_videos = os.path.join(crnt_yrs_subfolder2_path_videos, dt_mnthsno_mnths)

            # Current 'month number-month' folder in 'Audios' folder path
            crnt_mnthsno_mnths_subfolder3_path_audios = os.path.join(crnt_yrs_subfolder2_path_audios, dt_mnthsno_mnths)

            # Current 'date' folder in 'month number-month' folder from 'Videos' folder path
            crnt_date_subfolder4_path_videos = os.path.join(crnt_mnthsno_mnths_subfolder3_path_videos, dt_date)

            # Current 'date' folder in 'month number-month' folder from 'Audios' folder path
            crnt_date_subfolder4_path_audios = os.path.join(crnt_mnthsno_mnths_subfolder3_path_audios, dt_date)

            dir_lsts = [appdl_folder_path , playlist_videos_subfolder1_path , playlist_audios_subfolder1_path , videos_subfolder1_path , audios_subfolder1_path , crnt_yrs_subfolder2_path_playlist_videos , crnt_yrs_subfolder2_path_playlist_audios , crnt_mnthsno_mnths_subfolder3_path_playlist_videos, crnt_mnthsno_mnths_subfolder3_path_playlist_audios , crnt_date_subfolder4_path_playlist_videos , crnt_date_subfolder4_path_playlist_audios , crnt_yrs_subfolder2_path_videos , crnt_yrs_subfolder2_path_videos , crnt_mnthsno_mnths_subfolder3_path_videos , crnt_mnthsno_mnths_subfolder3_path_audios , crnt_date_subfolder4_path_videos , crnt_date_subfolder4_path_audios]

            self.app_downloads_folders_maker(paths_1=dir_lsts,folder_name=main_folder_name)
            
            self.delay(0.16)
        
            return appdl_folder_path , playlist_videos_subfolder1_path , playlist_audios_subfolder1_path , videos_subfolder1_path , audios_subfolder1_path , crnt_yrs_subfolder2_path_playlist_videos , crnt_yrs_subfolder2_path_playlist_audios , crnt_mnthsno_mnths_subfolder3_path_playlist_videos, crnt_mnthsno_mnths_subfolder3_path_playlist_audios , crnt_date_subfolder4_path_playlist_videos , crnt_date_subfolder4_path_playlist_audios , crnt_yrs_subfolder2_path_videos , crnt_yrs_subfolder2_path_videos , crnt_mnthsno_mnths_subfolder3_path_videos , crnt_mnthsno_mnths_subfolder3_path_audios , crnt_date_subfolder4_path_videos , crnt_date_subfolder4_path_audios
        except FileNotFoundError:
            pass

    def open_logsfolder(self):
 
        log_dirname = "Logs"
        logs_folder_path = os.path.join(cdir,log_dirname)

        try:
            os.makedirs(logs_folder_path)
        except OSError:
            pass

        os.startfile(logs_folder_path)

    def open_logsfl(self):
 
        try:
            os.makedirs(logs_folder_path)
        except OSError:
            pass

        logfl_path = os.path.join(logs_folder_path,log_fl)

        if os.path.exists(logfl_path)==False:
            with open(logfl_path,"w") as logfl_w6:
                logfl_w6.writable()
        else:
            pass

        os.startfile(logfl_path)
   
    def app_downloads_folders_maker(self,paths_1,folder_name):

        for dir in paths_1:

            try:
                os.makedirs(dir)
            except OSError:
                pass
            
            
            if dir == paths_1[0]:
                shortcut_fl = f'{folder_name} - Shortcut.lnk'

                desktop = winshell.desktop()
                path = os.path.join(desktop, shortcut_fl)

                ''' Make 'AppName' using "shortcut maker" protcol '''
                # 'if' -> if shortcut is not found at system desktop, creates it
                # Or 'else' -> skips 'shortcut maker' protocol if the json is found

                target = dir
                wDir = dir
                if os.path.exists(path)== False:
                    # file_name, file_type = os.path.splitext(os.path.basename(os.path.realpath(__file__)))
                    shell = Dispatch('WScript.Shell')
                    shortcut = shell.CreateShortCut(path)
                    shortcut.Targetpath = target
                    shortcut.WorkingDirectory = wDir
                    shortcut.save()
                else:
                    pass
            else:
                pass

    def open_app_dlsfolder(self):
        self.save_path_json()
        if os.path.exists(paths_datas_json_file_path) == True:
            returned_appdl_folder_path , returned_playlist_videos_subfolder1_path , returned_playlist_audios_subfolder1_path , returned_videos_subfolder1_path , returned_audios_subfolder1_path , returned_crnt_yrs_subfolder2_path_playlist_videos , returned_crnt_yrs_subfolder2_path_playlist_audios , returned_crnt_mnthsno_mnths_subfolder3_path_playlist_videos, returned_crnt_mnthsno_mnths_subfolder3_path_playlist_audios , returned_crnt_date_subfolder4_path_playlist_videos , returned_crnt_date_subfolder4_path_playlist_audios , returned_crnt_yrs_subfolder2_path_videos , returned_crnt_yrs_subfolder2_path_videos , crnt_mnthsno_mnths_subfolder3_path_videos , returned_crnt_mnthsno_mnths_subfolder3_path_audios , returned_crnt_date_subfolder4_path_videos , returned_crnt_date_subfolder4_path_audios =self.get_json_paths()
            # Getting the list of items in a directories
            # lst_dir1 = os.listdir(returned_appdl_folder_path)

            os.startfile(returned_appdl_folder_path)
        else:
            pass

    def open_app_audios_folder(self):
        self.save_path_json()
        if os.path.exists(paths_datas_json_file_path) == True:
            returned_appdl_folder_path , returned_playlist_videos_subfolder1_path , returned_playlist_audios_subfolder1_path , returned_videos_subfolder1_path , returned_audios_subfolder1_path , returned_crnt_yrs_subfolder2_path_playlist_videos , returned_crnt_yrs_subfolder2_path_playlist_audios , returned_crnt_mnthsno_mnths_subfolder3_path_playlist_videos, returned_crnt_mnthsno_mnths_subfolder3_path_playlist_audios , returned_crnt_date_subfolder4_path_playlist_videos , returned_crnt_date_subfolder4_path_playlist_audios , returned_crnt_yrs_subfolder2_path_videos , returned_crnt_yrs_subfolder2_path_videos , crnt_mnthsno_mnths_subfolder3_path_videos , returned_crnt_mnthsno_mnths_subfolder3_path_audios , returned_crnt_date_subfolder4_path_videos , returned_crnt_date_subfolder4_path_audios =self.get_json_paths()
            # Getting the list of items in a directories
            lst_dir4_audios = os.listdir(returned_crnt_date_subfolder4_path_audios)

            if len(lst_dir4_audios)==0:
                logerr_txt = f"Access Denied: No audio files found in directory '{returned_crnt_date_subfolder4_path_audios}'."
                self.apps_log_sys(logerr_msg=logerr_txt,err_msgtitle="Access denied - No audios files found: ",err_msgtxt=f"No audio files found in '{audios_folder_name}' folder")
            else:
                os.startfile(returned_crnt_date_subfolder4_path_audios)
        else:
            pass

    def open_app_videos_folder(self):
        self.save_path_json()
        if os.path.exists(paths_datas_json_file_path) == True:
            returned_appdl_folder_path , returned_playlist_videos_subfolder1_path , returned_playlist_audios_subfolder1_path , returned_videos_subfolder1_path , returned_audios_subfolder1_path , returned_crnt_yrs_subfolder2_path_playlist_videos , returned_crnt_yrs_subfolder2_path_playlist_audios , returned_crnt_mnthsno_mnths_subfolder3_path_playlist_videos, returned_crnt_mnthsno_mnths_subfolder3_path_playlist_audios , returned_crnt_date_subfolder4_path_playlist_videos , returned_crnt_date_subfolder4_path_playlist_audios , returned_crnt_yrs_subfolder2_path_videos , returned_crnt_yrs_subfolder2_path_videos , crnt_mnthsno_mnths_subfolder3_path_videos , returned_crnt_mnthsno_mnths_subfolder3_path_audios , returned_crnt_date_subfolder4_path_videos , returned_crnt_date_subfolder4_path_audios =self.get_json_paths()
            # Getting the list of items in a directories
            lst_dir4_videos = os.listdir(returned_crnt_date_subfolder4_path_videos)
            
            if len(lst_dir4_videos)==0:
                logerr_txt = f"Access Denied: No video files found in directory '{returned_crnt_date_subfolder4_path_videos}'."
                self.apps_log_sys(logerr_msg=logerr_txt,err_msgtitle="Access denied - No video files found: ",err_msgtxt=f"No videos files found in '{videos_folder_name}' folder")
            else:
                os.startfile(returned_crnt_date_subfolder4_path_videos)
        else:
            pass
        
    def open_app_playlist_audios_folder(self):
        self.save_path_json()
        if os.path.exists(paths_datas_json_file_path) == True:
            returned_appdl_folder_path , returned_playlist_videos_subfolder1_path , returned_playlist_audios_subfolder1_path , returned_videos_subfolder1_path , returned_audios_subfolder1_path , returned_crnt_yrs_subfolder2_path_playlist_videos , returned_crnt_yrs_subfolder2_path_playlist_audios , returned_crnt_mnthsno_mnths_subfolder3_path_playlist_videos, returned_crnt_mnthsno_mnths_subfolder3_path_playlist_audios , returned_crnt_date_subfolder4_path_playlist_videos , returned_crnt_date_subfolder4_path_playlist_audios , returned_crnt_yrs_subfolder2_path_videos , returned_crnt_yrs_subfolder2_path_videos , crnt_mnthsno_mnths_subfolder3_path_videos , returned_crnt_mnthsno_mnths_subfolder3_path_audios , returned_crnt_date_subfolder4_path_videos , returned_crnt_date_subfolder4_path_audios =self.get_json_paths()
            # Getting the list of items in a directories
            lst_dir4_playlist_audios = os.listdir(returned_crnt_date_subfolder4_path_playlist_audios)
            
            if len(lst_dir4_playlist_audios)==0:
                logerr_txt = f"Access Denied: No playlist audio files found in directory '{returned_crnt_date_subfolder4_path_playlist_audios}'."
                self.apps_log_sys(logerr_msg=logerr_txt,err_msgtitle="Access denied - No playlist audios files found: ",err_msgtxt=f"No playlist videos found in '{playlist_audios_folder_name}' folder")
            else:
                os.startfile(returned_crnt_date_subfolder4_path_playlist_audios)
        else:
            pass

    def open_app_playlist_videos_folder(self):
        self.save_path_json()
        if os.path.exists(paths_datas_json_file_path) == True:
            returned_appdl_folder_path , returned_playlist_videos_subfolder1_path , returned_playlist_audios_subfolder1_path , returned_videos_subfolder1_path , returned_audios_subfolder1_path , returned_crnt_yrs_subfolder2_path_playlist_videos , returned_crnt_yrs_subfolder2_path_playlist_audios , returned_crnt_mnthsno_mnths_subfolder3_path_playlist_videos, returned_crnt_mnthsno_mnths_subfolder3_path_playlist_audios , returned_crnt_date_subfolder4_path_playlist_videos , returned_crnt_date_subfolder4_path_playlist_audios , returned_crnt_yrs_subfolder2_path_videos , returned_crnt_yrs_subfolder2_path_videos , crnt_mnthsno_mnths_subfolder3_path_videos , returned_crnt_mnthsno_mnths_subfolder3_path_audios , returned_crnt_date_subfolder4_path_videos , returned_crnt_date_subfolder4_path_audios =self.get_json_paths()
            # Getting the list of items in a directories
            lst_dir4_playlist_videos = os.listdir(returned_crnt_date_subfolder4_path_videos)

            if len(lst_dir4_playlist_videos)==0:
                logerr_txt = f"Access Denied: No playlist video files found in directory '{returned_crnt_date_subfolder4_path_videos}'."
                self.apps_log_sys(logerr_msg=logerr_txt,err_msgtitle="Access denied - No playlist video files found: ",err_msgtxt=f"No playlist video files found in '{playlist_videos_folder_name}' folder")
            else:
                os.startfile(returned_crnt_date_subfolder4_path_videos)
        else:
            pass

    def video_dl(self):
        self.save_path_json()

        if os.path.exists(paths_datas_json_file_path) == True:
            get_yt_url = self.link_input.text()
            get_yt_res = self.res_combobox.currentText()
            
            returned_appdl_folder_path , returned_playlist_videos_subfolder1_path , returned_playlist_audios_subfolder1_path , returned_videos_subfolder1_path , returned_audios_subfolder1_path , returned_crnt_yrs_subfolder2_path_playlist_videos , returned_crnt_yrs_subfolder2_path_playlist_audios , returned_crnt_mnthsno_mnths_subfolder3_path_playlist_videos, returned_crnt_mnthsno_mnths_subfolder3_path_playlist_audios , returned_crnt_date_subfolder4_path_playlist_videos , returned_crnt_date_subfolder4_path_playlist_audios , returned_crnt_yrs_subfolder2_path_videos , returned_crnt_yrs_subfolder2_path_videos , crnt_mnthsno_mnths_subfolder3_path_videos , returned_crnt_mnthsno_mnths_subfolder3_path_audios , returned_crnt_date_subfolder4_path_videos , returned_crnt_date_subfolder4_path_audios =self.get_json_paths()

            if get_yt_url !="":
                if "youtube" in get_yt_url or "youtu.be" in get_yt_url:
                    if 'playlist' in get_yt_url or 'list' in get_yt_url:
                        if 'index' in get_yt_url:
                            self.yt_one_vid(res1=get_yt_res,url1=get_yt_url,path1=returned_crnt_date_subfolder4_path_videos)
                        else:
                            self.yt_playlist_vid(res2=get_yt_res,url2=get_yt_url,path2=returned_crnt_date_subfolder4_path_playlist_videos)
                    elif 'playlist' not in get_yt_url or 'list' not in get_yt_url:
                        self.yt_one_vid(res1=get_yt_res,url1=get_yt_url,path1=returned_crnt_date_subfolder4_path_videos)
                    else:
                        pass
                else:
                    self.link_input.clear()
                    self.msg_autoClose(msg_text="Only youtube links are accepted. Please verify your url.",msg_title=r"Invalid Url\link:",close_tmr=3,msg_icon=QMessageBox.Critical)
            else:
                self.msg_autoClose(msg_text="Empty values are not accepted.",msg_title="Input invalid:",close_tmr=3,msg_icon=QMessageBox.Critical)
        else:
            pass

    def yt_one_vid(self,res1,url1,path1):
        # print("Video saved using url: "+url1+" & Video quality: "+res1)
        
        try:

            yt = pytube.YouTube(url1)
 
            video_name = yt.title

            video_id = yt.video_id

            video_format = "mp4"

            re_video_name_1 = video_name.replace("'","").replace(":","").replace("'","").replace("|","").replace("/","").replace("\\","").replace("<","").replace(">","").replace("*","").replace("?","")
 
            yt_src_video_file_renamed_1 = f"{re_video_name_1}_{video_id}.{video_format}"

            source_mp4_1 = os.path.join(path1,yt_src_video_file_renamed_1)

            re_video_name_2 = video_name.replace("'"," ").replace(":"," ").replace("'"," ").replace("|"," ").replace("/"," ").replace("\\"," ").replace("<"," ").replace(">"," ").replace("*"," ").replace("?"," ")
 
            yt_src_video_file_renamed_2 = f"{re_video_name_2}_{video_id}.{video_format}"

            source_mp4_2 = os.path.join(path1,yt_src_video_file_renamed_2)

            yt_age_restricted = yt.age_restricted

            if yt_age_restricted == False:

                if os.path.exists(source_mp4_1) == True:

                    self.link_input.clear()

                    self.res_combobox.setCurrentText("720p")

                    self.msg_autoClose(msg_text=f"'{re_video_name_1}' video already exists in {videos_folder_name}.",msg_title="YouTube saver Notify - Video exists",close_tmr=3,msg_icon=QMessageBox.Information)
                                                     
                    returned_msg_outs = self.yn_msgbox(txt5=f"Do you wish to delete '{re_video_name_1}' video ?",title5="Video Delete - Yes/No",msg_icon=QMessageBox.Question)

                    if returned_msg_outs == QMessageBox.No:
                        pass
                    elif returned_msg_outs == QMessageBox.Yes:
                        os.remove(source_mp4_1)

                        self.msg_autoClose(msg_text=f"Successfully deleted '{re_video_name_1}' video.",msg_title="Video Delete - Success",close_tmr=3,msg_icon=QMessageBox.Information)
                
                elif os.path.exists(source_mp4_2) == True:

                    self.link_input.clear()

                    self.res_combobox.setCurrentText("720p")

                    self.msg_autoClose(msg_text=f"'{re_video_name_2}' video already exists in {videos_folder_name}.",msg_title="YouTube saver Notify - Video exists",close_tmr=3,msg_icon=QMessageBox.Information)
                                                     
                    returned_msg_outs = self.yn_msgbox(txt5=f"Do you wish to delete '{re_video_name_2}' video ?",title5="Video Delete - Yes/No",msg_icon=QMessageBox.Question)

                    if returned_msg_outs == QMessageBox.No:
                        pass
                    elif returned_msg_outs == QMessageBox.Yes:
                        os.remove(source_mp4_2)

                        self.msg_autoClose(msg_text=f"Successfully deleted '{re_video_name_1}' video.",msg_title="Video Delete - Success",close_tmr=3,msg_icon=QMessageBox.Information)

                else:

                    self.msg_autoClose(msg_text="Started to download video.",msg_title="YouTube saver Notify - Video Download Started",close_tmr=3,msg_icon=QMessageBox.Information)
                                                    
                    # download the video
                    returned_yt_video_dl_name = self.pytube_video_dwnld(yt_attrib6=yt,res6=res1,path6=path1,ytvid_id6=video_id)
    
                    if returned_yt_video_dl_name !=None:
                        self.msg_autoClose(msg_text=f"'{returned_yt_video_dl_name}' video has been successfully downloaded in '{videos_folder_name}' folder.",msg_title="Video Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)

                        if url1=="":
                                    
                            pass
                                                
                        else:

                            self.delay(1.76)

                            returned_msg_outs = self.yn_msgbox(txt5="Do you wish to download another video from YouTube ?",title5="Yes/No",msg_icon=QMessageBox.Question)

                            if returned_msg_outs == QMessageBox.No:
                                pass
                            elif returned_msg_outs == QMessageBox.Yes:
                                self.link_input.clear()

                                self.res_combobox.setCurrentText("720p")

                                self.msg_autoClose(msg_text="All values reseted.",msg_title="Notify - Reset Done",close_tmr=3,msg_icon=QMessageBox.Information)
                            else:
                                pass

                    else:
                        self.msg_autoClose(msg_text=f"All download attempts failed.",msg_title="Video Download - Failed.",close_tmr=3,msg_icon=QMessageBox.Close)
            else:
                self.link_input.clear()

                self.res_combobox.setCurrentText("720p")
                self.msg_autoClose(msg_text="Oops! Sorry, could not download video due to age restriction.",msg_title="Video download failed - Age restriction detected",close_tmr=3,msg_icon=QMessageBox.Information)
        except pytube.exceptions.ExtractError as py_yt_extractErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=(py_yt_extractErr),err_msgtitle="YouTube Saver - Extraction error:",err_msgtxt=f"Oops! couldn't extract data from link the '{url1}'.")
            
        except pytube.exceptions.HTMLParseError as py_yt_htmlErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_htmlErr),err_msgtitle="YouTube Saver - HTML parser error:",err_msgtxt=f"Oops! Sorry couldn't parse HTML form the link '{url1}'.")

        except pytube.exceptions.LiveStreamError as py_yt_liveStreamErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_liveStreamErr),err_msgtitle="YouTube saver - Live stream error:",err_msgtxt=f"Oops! couldn't download a live video stream from the link '{url1}'.")

        except pytube.exceptions.MaxRetriesExceeded as py_yt_maxLmtErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")
            
            self.apps_log_sys(logerr_msg=str(py_yt_maxLmtErr),err_msgtitle="YouTube saver - Maximum retries error:",err_msgtxt="Oops! Sorry retries exceeded maximum limit.")

        except pytube.exceptions.MembersOnly as py_yt_membersOnlyErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_membersOnlyErr),err_msgtitle="YouTube saver - Members only error:",err_msgtxt="Sorry, looks like the video can be acesses by members only.")

        except pytube.exceptions.RecordingUnavailable as py_yt_RecordingUnavailableErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_RecordingUnavailableErr),err_msgtitle="YouTube saver - Video recoding Unavailable error:",err_msgtxt="Looks like the video has no recording functionalties.")
 
        except pytube.exceptions.VideoPrivate as py_yt_VideoPrivateErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoPrivateErr),err_msgtitle="YouTube saver - Video private error:",err_msgtxt="The video is set to private by the owner.")
            
        except pytube.exceptions.VideoRegionBlocked as py_yt_VideoRegionBlockedErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoRegionBlockedErr),err_msgtitle="YouTube saver - Video regional error:",err_msgtxt="Seems like the video is blocked at your country or current region.")
                                   
        except pytube.exceptions.VideoUnavailable as py_yt_VideoUnavailableErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoUnavailableErr),err_msgtitle="YouTube saver - Video unavailable error:",err_msgtxt="Seems like the video is not available.")

        except AttributeError as yt_AttErr:

            #print(str(yt_AttErr))

            self.apps_log_sys(logerr_msg=str(yt_AttErr),err_msgtitle="YouTube saver - Attribute error:",err_msgtxt=str(yt_AttErr))

        except pytube.exceptions.PytubeError as yt_req_err:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(yt_req_err),err_msgtitle="YouTube saver - Request error:",err_msgtxt=str(yt_req_err))
 
        except FileNotFoundError as yt_files_unexists_err:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(yt_files_unexists_err),err_msgtitle="YouTube saver - Video download error:",err_msgtxt=str(yt_files_unexists_err))
 
        except Exception as yt_err:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(yt_err),err_msgtitle="YouTube saver - error:",err_msgtxt=str(yt_err))
 
    def yt_playlist_vid(self,res2,url2,path2):
        # print("Videos saved using playlist url: "+url2+" & Video quality: "+res2)

        try:

            yt_playlist_infos = pytube.Playlist(url2)

            playlist_URLS = yt_playlist_infos.video_urls

            playlist_title = yt_playlist_infos.title

            playlist_title_re = playlist_title.replace("'"," ").replace(":"," ").replace("'"," ").replace("|"," ").replace("/"," ").replace("\\"," ").replace("<"," ").replace(">"," ").replace("*"," ").replace("?"," ")

            playlist_videos_title_sub_folder = os.path.join(path2,playlist_title_re)
                            
            try:

                os.makedirs(playlist_videos_title_sub_folder)
                            
            except OSError:

                pass

            yt_cj_modes = ['Selective (Picky choices)','Complete (Full set)']

            returned_lstsbox_gui_out , returned_lstsbox_item_out = self.lists_box(l2=yt_cj_modes,title2="YouTube Saver - 'Candy jar'",txt2="Choose your 'Candy' mode")

            if returned_lstsbox_gui_out == wx.ID_OK:

                #print ("YT saver mode, %s\n" % onechoice.GetStringSelection())

                if "Selective" in returned_lstsbox_item_out:

                    while True:

                        n1_in = QInputDialog(self)
                        n1_in.setWindowTitle("First order of YouTube playlist video:")
                        n1_in.setLabelText(f"Enter first order of the video in YouTube playlist '{playlist_title}'.") 
                        n1_in.setTextEchoMode(QLineEdit.Password)
                            
                        n1_in.setFixedSize(400, 240)

                        n1_in.setStyleSheet(
                                """
                                
                                QLabel{
                                    font-size:20px;
                                        
                                    font-family:Arial;
                                    }
                                    
                                QLineEdit{
                                    font-size:20px;
                                    font-family:Arial;
                                    }
                                    
                                QPushButton{
                                    font-size:20px;                         
                                    }
                                """
                                    )
                        okPressed_n1 = n1_in.exec_()
                        n1_txt = n1_in.textValue()

                        if okPressed_n1==True and n1_txt != '':

                            try:
                                playlist_n1 = int(n1_txt)-1
                                                
                                break
                            except ValueError:
                                #pass
   
                                self.msg_autoClose(msg_text="Please enter the number (eg: 0 or 1).",msg_title="Input invalid:",close_tmr=3,msg_icon=QMessageBox.Critical)
                        else:

                            self.msg_autoClose(msg_text="Null value not accepted. So please enter the number.",msg_title="Null error:",close_tmr=3,msg_icon=QMessageBox.Information)

    
                    while True:

                        n2_in = QInputDialog(self)
                        n2_in.setWindowTitle("Second order of YouTube playlist video:")
                        n2_in.setLabelText(f"Enter second order of the video in YouTube playlist '{playlist_title}'.")
                        n2_in.setTextEchoMode(QLineEdit.Password)
                            
                        n2_in.setFixedSize(400, 240)

                        n2_in.setStyleSheet(
                                """
                                
                                QLabel{
                                    font-size:20px;
                                        
                                    font-family:Arial;
                                    }
                                    
                                QLineEdit{
                                    font-size:20px;
                                    font-family:Arial;
                                    }
                                    
                                QPushButton{
                                    font-size:20px;                         
                                    }
                                """
                                    )
                        okPressed_n2 = n2_in.exec_()
                        n2_txt = n2_in.textValue()

                        if okPressed_n2==True and n2_txt != '':

                            try:
                                playlist_n2 = int(n2_txt)
                                                
                                break
                            except ValueError:
                                #pass
   
                                self.msg_autoClose(msg_text="Please enter the number (eg: 0 or 1).",msg_title="Input invalid:",close_tmr=3,msg_icon=QMessageBox.Critical)
                        else:

                            self.msg_autoClose(msg_text="Null value not accepted. So please enter the number.",msg_title="Null error:",close_tmr=3,msg_icon=QMessageBox.Information)
    

                    for yt_video_url in yt_playlist_infos.video_urls[playlist_n1:playlist_n2]:
                        try:

                            yt = pytube.YouTube(yt_video_url)

                            video_name = yt.title

                            video_id = yt.video_id

                            video_format = "mp4"

                            re_video_name_1 = video_name.replace("'","").replace(":","").replace("'","").replace("|","").replace("/","").replace("\\","").replace("<","").replace(">","").replace("*","").replace("?","")
 
                            yt_src_video_file_renamed_1 = f"{re_video_name_1}_{video_id}.{video_format}"

                            source_mp4_1 = os.path.join(path2,yt_src_video_file_renamed_1)

                            re_video_name_2 = video_name.replace("'"," ").replace(":"," ").replace("'"," ").replace("|"," ").replace("/"," ").replace("\\"," ").replace("<"," ").replace(">"," ").replace("*"," ").replace("?"," ")
                
                            yt_src_video_file_renamed_2 = f"{re_video_name_2}_{video_id}.{video_format}"

                            source_mp4_2 = os.path.join(path2,yt_src_video_file_renamed_2)

                            yt_age_restricted = yt.age_restricted

                            if yt_age_restricted == False:

                                if os.path.exists(source_mp4_1) is True:

                                    self.link_input.clear()

                                    self.res_combobox.setCurrentText("720p")

                                    self.msg_autoClose(msg_text=f"'{re_video_name_1}' video already exists in '{playlist_title_re}' video playlist folder.",msg_title="YouTube saver Notify - Video exists",close_tmr=3,msg_icon=QMessageBox.Information)
                               
                                elif os.path.exists(source_mp4_2) is True:

                                    self.link_input.clear()

                                    self.res_combobox.setCurrentText("720p")

                                    self.msg_autoClose(msg_text=f"'{re_video_name_2}' video already exists in '{playlist_title_re}' video playlist folder.",msg_title="YouTube saver Notify - Video exists",close_tmr=3,msg_icon=QMessageBox.Information)

                                else:

                                    self.msg_autoClose(msg_text="Started to download video.",msg_title="YouTube saver Notify - Video Download Started",close_tmr=3,msg_icon=QMessageBox.Information)
                                                                    
                                    # download the video
                                    returned_yt_video_dl_name = self.pytube_video_dwnld(yt_attrib6=yt,res6=res2,path6=playlist_videos_title_sub_folder,ytvid_id6=video_id)

                                    if returned_yt_video_dl_name != None:
                                        self.msg_autoClose(msg_text=f"'{returned_yt_video_dl_name}' video has been successfully downloaded in '{videos_folder_name}' video playlist folder.",msg_title="Video Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)
                                    else:
                                        self.msg_autoClose(msg_text=f"All download attempts failed.",msg_title="Video Download - Failed.",close_tmr=3,msg_icon=QMessageBox.Close)
                            else:
                                self.msg_autoClose(msg_text="Oops! Sorry, could not download video due to age restriction.",msg_title="Video download failed - Age restriction detected",close_tmr=3,msg_icon=QMessageBox.Information)
                        except pytube.exceptions.ExtractError as py_yt_extractErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=(py_yt_extractErr),err_msgtitle="YouTube Saver - Extraction error:",err_msgtxt=f"Oops! couldn't extract data from link the '{url2}'.")
                            
                        except pytube.exceptions.HTMLParseError as py_yt_htmlErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_htmlErr),err_msgtitle="YouTube Saver - HTML parser error:",err_msgtxt=f"Oops! Sorry couldn't parse HTML form the link '{url2}'.")

                            
                        except pytube.exceptions.LiveStreamError as py_yt_liveStreamErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_liveStreamErr),err_msgtitle="YouTube saver - Live stream error:",err_msgtxt=f"Oops! couldn't download a live video stream from the link '{url2}'.")

                        except pytube.exceptions.MaxRetriesExceeded as py_yt_maxLmtErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")
                            
                            self.apps_log_sys(logerr_msg=str(py_yt_maxLmtErr),err_msgtitle="YouTube saver - Maximum retries error:",err_msgtxt="Oops! Sorry retries exceeded maximum limit.")

                        except pytube.exceptions.MembersOnly as py_yt_membersOnlyErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_membersOnlyErr),err_msgtitle="YouTube saver - Members only error:",err_msgtxt="Sorry, looks like the video can be acesses by members only.")

                        except pytube.exceptions.RecordingUnavailable as py_yt_RecordingUnavailableErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_RecordingUnavailableErr),err_msgtitle="YouTube saver - Video recoding Unavailable error:",err_msgtxt="Looks like the video has no recording functionalties.")
                
                        except pytube.exceptions.VideoPrivate as py_yt_VideoPrivateErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoPrivateErr),err_msgtitle="YouTube saver - Video private error:",err_msgtxt="The video is set to private by the owner.")
                            
                        except pytube.exceptions.VideoRegionBlocked as py_yt_VideoRegionBlockedErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoRegionBlockedErr),err_msgtitle="YouTube saver - Video regional error:",err_msgtxt="Seems like the video is blocked at your country or current region.")
                                                
                        except pytube.exceptions.VideoUnavailable as py_yt_VideoUnavailableErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoUnavailableErr),err_msgtitle="YouTube saver - Video unavailable error:",err_msgtxt="Seems like the video is not available.")

                        except AttributeError as yt_AttErr:

                            #print(str(yt_AttErr))

                            self.apps_log_sys(logerr_msg=str(yt_AttErr),err_msgtitle="YouTube saver - Attribute error:",err_msgtxt=str(yt_AttErr))

                        except pytube.exceptions.PytubeError as yt_req_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_req_err),err_msgtitle="YouTube saver - Request error:",err_msgtxt=str(yt_req_err))
                
                        except FileNotFoundError as yt_files_unexists_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_files_unexists_err),err_msgtitle="YouTube saver - Video download error:",err_msgtxt=str(yt_files_unexists_err))

                        except Exception as yt_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_err),err_msgtitle="YouTube saver - error:",err_msgtxt=str(yt_err)) 

                    self.msg_autoClose(msg_text=f"Selected videos has been successfully downloaded in '{playlist_title_re}' folder.",msg_title="Playlists Audios Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)
        
                    if url2=="":
                                    
                        pass
                                                
                    else:

                        self.delay(1.76)

                        returned_msg_outs = self.yn_msgbox(txt5="Do you wish to download another video from YouTube ?",title5="Yes/No",msg_icon=QMessageBox.Question)

                        if returned_msg_outs == QMessageBox.No:
                            pass
                        elif returned_msg_outs == QMessageBox.Yes:
                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.msg_autoClose(msg_text="All values reseted.",msg_title="Notify - Reset Done",close_tmr=3,msg_icon=QMessageBox.Information)
                        else:
                            pass
 
                else:

                    playlist_video_n = len(playlist_URLS)

                    for yt_video_url in yt_playlist_infos.video_urls[0:playlist_video_n]:

                        try:

                            yt = pytube.YouTube(yt_video_url)

                            video_name = yt.title

                            video_id = yt.video_id

                            video_format = "mp4"

                            re_video_name_1 = video_name.replace("'","").replace(":","").replace("'","").replace("|","").replace("/","").replace("\\","").replace("<","").replace(">","").replace("*","").replace("?","")
 
                            yt_src_video_file_renamed_1 = f"{re_video_name_1}.{video_format}"

                            source_mp4_1 = os.path.join(path2,yt_src_video_file_renamed_1)

                            re_video_name_2 = video_name.replace("'"," ").replace(":"," ").replace("'"," ").replace("|"," ").replace("/"," ").replace("\\"," ").replace("<"," ").replace(">"," ").replace("*"," ").replace("?"," ")
                
                            yt_src_video_file_renamed_2 = f"{re_video_name_2}.{video_format}"

                            source_mp4_2 = os.path.join(path2,yt_src_video_file_renamed_2)
 
                            yt_age_restricted = yt.age_restricted

                            if yt_age_restricted == False:

                                if os.path.exists(source_mp4_1) is True:

                                    self.link_input.clear()

                                    self.res_combobox.setCurrentText("720p")

                                    self.msg_autoClose(msg_text=f"'{re_video_name_1}' video already exists in '{playlist_title_re}' video playlist folder.",msg_title="YouTube saver Notify - Video exists",close_tmr=3,msg_icon=QMessageBox.Information)

                                elif os.path.exists(source_mp4_2) is True:

                                    self.link_input.clear()

                                    self.res_combobox.setCurrentText("720p")

                                    self.msg_autoClose(msg_text=f"'{re_video_name_2}' video already exists in '{playlist_title_re}' video playlist folder.",msg_title="YouTube saver Notify - Video exists",close_tmr=3,msg_icon=QMessageBox.Information)
                                                                       
                                else:

                                    self.msg_autoClose(msg_text="Started to download video.",msg_title="YouTube saver Notify - Video Download Started",close_tmr=3,msg_icon=QMessageBox.Information)
                                                                    
                                    # download the video
                                    returned_yt_video_dl_name = self.pytube_video_dwnld(yt_attrib6=yt,res6=res2,path6=playlist_videos_title_sub_folder,ytvid_id6=video_id)

                                    if returned_yt_video_dl_name != None:
                                        self.msg_autoClose(msg_text=f"'{returned_yt_video_dl_name}' video has been successfully downloaded in '{playlist_title_re}' video playlist folder.",msg_title="Video Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)
                                    else:
                                        self.msg_autoClose(msg_text=f"All download attempts failed.",msg_title="Video Download - Failed.",close_tmr=3,msg_icon=QMessageBox.Close)
                            else:
                                self.msg_autoClose(msg_text="Oops! Sorry, could not download video due to age restriction.",msg_title="Video download failed - Age restriction detected",close_tmr=3,msg_icon=QMessageBox.Information)
                        except pytube.exceptions.ExtractError as py_yt_extractErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=(py_yt_extractErr),err_msgtitle="YouTube Saver - Extraction error:",err_msgtxt=f"Oops! couldn't extract data from link the '{url2}'.")
                            
                        except pytube.exceptions.HTMLParseError as py_yt_htmlErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_htmlErr),err_msgtitle="YouTube Saver - HTML parser error:",err_msgtxt=f"Oops! Sorry couldn't parse HTML form the link '{url2}'.")

                            
                        except pytube.exceptions.LiveStreamError as py_yt_liveStreamErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_liveStreamErr),err_msgtitle="YouTube saver - Live stream error:",err_msgtxt=f"Oops! couldn't download a live video stream from the link '{url2}'.")

                        except pytube.exceptions.MaxRetriesExceeded as py_yt_maxLmtErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")
                            
                            self.apps_log_sys(logerr_msg=str(py_yt_maxLmtErr),err_msgtitle="YouTube saver - Maximum retries error:",err_msgtxt="Oops! Sorry retries exceeded maximum limit.")

                        except pytube.exceptions.MembersOnly as py_yt_membersOnlyErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_membersOnlyErr),err_msgtitle="YouTube saver - Members only error:",err_msgtxt="Sorry, looks like the video can be acesses by members only.")

                        except pytube.exceptions.RecordingUnavailable as py_yt_RecordingUnavailableErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_RecordingUnavailableErr),err_msgtitle="YouTube saver - Video recoding Unavailable error:",err_msgtxt="Looks like the video has no recording functionalties.")
                
                        except pytube.exceptions.VideoPrivate as py_yt_VideoPrivateErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoPrivateErr),err_msgtitle="YouTube saver - Video private error:",err_msgtxt="The video is set to private by the owner.")
                            
                        except pytube.exceptions.VideoRegionBlocked as py_yt_VideoRegionBlockedErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoRegionBlockedErr),err_msgtitle="YouTube saver - Video regional error:",err_msgtxt="Seems like the video is blocked at your country or current region.")
                                                
                        except pytube.exceptions.VideoUnavailable as py_yt_VideoUnavailableErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoUnavailableErr),err_msgtitle="YouTube saver - Video unavailable error:",err_msgtxt="Seems like the video is not available.")

                        except AttributeError as yt_AttErr:

                            #print(str(yt_AttErr))

                            self.apps_log_sys(logerr_msg=str(yt_AttErr),err_msgtitle="YouTube saver - Attribute error:",err_msgtxt=str(yt_AttErr))

                        except pytube.exceptions.PytubeError as yt_req_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_req_err),err_msgtitle="YouTube saver - Request error:",err_msgtxt=str(yt_req_err))
                
                        except FileNotFoundError as yt_files_unexists_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_files_unexists_err),err_msgtitle="YouTube saver - Video download error:",err_msgtxt=str(yt_files_unexists_err))

                        except Exception as yt_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_err),err_msgtitle="YouTube saver - error:",err_msgtxt=str(yt_err)) 

                    if len(os.listdir(path2))==len(yt_playlist_infos.video_urls):
                        self.msg_autoClose(msg_text=f"All videos has been successfully downloaded in '{playlist_title_re}' folder.",msg_title="Playlists Videos Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)
            
                        if url2=="" and self.res_combobox.currentText()=="720p":
                                        
                            pass
                                                    
                        else:

                            self.delay(1.76)

                            returned_msg_outs = self.yn_msgbox(txt5="Do you wish to download another video from YouTube ?",title5="Yes/No",msg_icon=QMessageBox.Question)

                            if returned_msg_outs == QMessageBox.No:
                                pass
                            elif returned_msg_outs == QMessageBox.Yes:
                                self.link_input.clear()

                                self.res_combobox.setCurrentText("720p")

                                self.msg_autoClose(msg_text="All values reseted.",msg_title="Notify - Reset Done",close_tmr=3,msg_icon=QMessageBox.Information)
                            else:
                                pass
                    else:
                        pass
        
        except pytube.exceptions.ExtractError as py_yt_extractErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=(py_yt_extractErr),err_msgtitle="YouTube Saver - Extraction error:",err_msgtxt=f"Oops! couldn't extract playlist data from link the '{url2}'.")
            
        except pytube.exceptions.HTMLParseError as py_yt_htmlErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_htmlErr),err_msgtitle="YouTube Saver - HTML parser error:",err_msgtxt=f"Oops! Sorry couldn't parse HTML form the playlist link '{url2}'.")
   
        except pytube.exceptions.LiveStreamError as py_yt_liveStreamErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_liveStreamErr),err_msgtitle="YouTube saver - Live stream error:",err_msgtxt=f"Oops! couldn't download playlist stream stream from the link '{url2}'.")

        except pytube.exceptions.MaxRetriesExceeded as py_yt_maxLmtErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")
            
            self.apps_log_sys(logerr_msg=str(py_yt_maxLmtErr),err_msgtitle="YouTube saver - Maximum retries error:",err_msgtxt="Oops! Sorry retries exceeded maximum limit.")

        except pytube.exceptions.MembersOnly as py_yt_membersOnlyErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_membersOnlyErr),err_msgtitle="YouTube saver - Members only error:",err_msgtxt="Sorry, looks like the playlist can be acesses by members only.")

        except pytube.exceptions.RecordingUnavailable as py_yt_RecordingUnavailableErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_RecordingUnavailableErr),err_msgtitle="YouTube saver - Video recoding Unavailable error:",err_msgtxt="Looks like the playlist has no recording functionalties.")
 
        except pytube.exceptions.VideoPrivate as py_yt_VideoPrivateErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoPrivateErr),err_msgtitle="YouTube saver - Playlist private error:",err_msgtxt="The playlists is set to private by the owner.")
            
        except pytube.exceptions.VideoRegionBlocked as py_yt_VideoRegionBlockedErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoRegionBlockedErr),err_msgtitle="YouTube saver - Playlist regional error:",err_msgtxt="Seems like the playlist is blocked at your country or current region.")
                                   
        except pytube.exceptions.VideoUnavailable as py_yt_VideoUnavailableErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoUnavailableErr),err_msgtitle="YouTube saver - Playlist unavailable error:",err_msgtxt="Seems like the playlist is not available.")

        except AttributeError as yt_AttErr:

            #print(str(yt_AttErr))

            self.apps_log_sys(logerr_msg=str(yt_AttErr),err_msgtitle="YouTube saver - Attribute error:",err_msgtxt=str(yt_AttErr))

        except pytube.exceptions.PytubeError as yt_req_err:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(yt_req_err),err_msgtitle="YouTube saver - Request error:",err_msgtxt=str(yt_req_err))
 
        except Exception as yt_err:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(yt_err),err_msgtitle="YouTube saver - error:",err_msgtxt=str(yt_err))
    
    def audio_dl(self):

        self.save_path_json()

        if os.path.exists(paths_datas_json_file_path) == True:
     
            get_yt_url2 = self.link_input.text()
      
            returned_appdl_folder_path , returned_playlist_videos_subfolder1_path , returned_playlist_audios_subfolder1_path , returned_videos_subfolder1_path , returned_audios_subfolder1_path , returned_crnt_yrs_subfolder2_path_playlist_videos , returned_crnt_yrs_subfolder2_path_playlist_audios , returned_crnt_mnthsno_mnths_subfolder3_path_playlist_videos, returned_crnt_mnthsno_mnths_subfolder3_path_playlist_audios , returned_crnt_date_subfolder4_path_playlist_videos , returned_crnt_date_subfolder4_path_playlist_audios , returned_crnt_yrs_subfolder2_path_videos , returned_crnt_yrs_subfolder2_path_videos , crnt_mnthsno_mnths_subfolder3_path_videos , returned_crnt_mnthsno_mnths_subfolder3_path_audios , returned_crnt_date_subfolder4_path_videos , returned_crnt_date_subfolder4_path_audios =self.get_json_paths()

            if get_yt_url2 !="":
                if "youtube" in get_yt_url2 or "youtu.be" in get_yt_url2:
                    if 'playlist' in get_yt_url2 or 'list' in get_yt_url2:
                        if 'index' in get_yt_url2:
                            self.yt_one_aud(res3="360p",url3=get_yt_url2,path3=returned_crnt_date_subfolder4_path_audios)
                        else:
                            self.yt_playlist_aud(res4="360p",url4=get_yt_url2,path4=returned_crnt_date_subfolder4_path_playlist_audios)
                    elif 'playlist' not in get_yt_url2 or 'list' not in get_yt_url2:
                        self.yt_one_aud(res3="360p",url3=get_yt_url2,path3=returned_crnt_date_subfolder4_path_audios)
                    else:
                        pass
                else:
                    self.link_input.clear()
                    self.msg_autoClose(msg_text="Only youtube links are accepted. Please verify your url.",msg_title=r"Invalid Url\link:",close_tmr=3,msg_icon=QMessageBox.Critical)
            else:
                self.msg_autoClose(msg_text="Empty values are accepted.",msg_title="Input invalid:",close_tmr=3,msg_icon=QMessageBox.Critical)
                
        else:
            pass

    def yt_one_aud(self,res3,url3,path3):

        try:

            yt = pytube.YouTube(url3)

            video_name = yt.title

            video_id = yt.video_id

            video_published_date = yt.publish_date.date().strftime('%d-%m-%Y')

            video_published_year = yt.publish_date.year

            video_author= yt.author

            video_format = "mp4"

            audio_format = "mp3"

            re_video_name_1 = video_name.replace('"','').replace(":","").replace("'","").replace("|","").replace("/","").replace("\\","").replace("<","").replace(">","").replace("*","").replace("?","")
                                            
            src_video_file_1 = f"{re_video_name_1}_{video_id}.{video_format}"

            # src_audio_file_1 = "{0}-{1}.{2}".format(re_video_name_1,video_id,audio_format)
 
            yt_src_audio_file_1 = f"{re_video_name_1}_{video_id}.{audio_format}"

            source_mp4_1 = os.path.join(path3,src_video_file_1)

            source_mp3_1 = os.path.join(path3,yt_src_audio_file_1)
            
            re_video_name_2 = video_name.replace('"',' ').replace(":"," ").replace("'"," ").replace("|"," ").replace("/"," ").replace("\\"," ").replace("<"," ").replace(">"," ").replace("*"," ").replace("?"," ")
                                            
            src_video_file_2 = f"{re_video_name_2}_{video_id}.{video_format}"

            # src_audio_file_2 = "{0}-{1}.{2}".format(re_video_name_2,video_id,audio_format)

            yt_src_audio_file_2 = f"{re_video_name_2}_{video_id}.{audio_format}"

            source_mp4_2 = os.path.join(path3,src_video_file_2)

            source_mp3_2 = os.path.join(path3,yt_src_audio_file_2)

            # source_mp3_id = os.path.join(path3,src_audio_file_2)

            yt_age_restricted = yt.age_restricted
            if yt_age_restricted == False:

                if os.path.exists(source_mp3_1) == True:

                    self.link_input.clear()

                    self.res_combobox.setCurrentText("720p")

                    self.msg_autoClose(msg_text=f"'{re_video_name_1}' audio already exists in {audios_folder_name}.",msg_title="YouTube saver Notify - Audio exists",close_tmr=3,msg_icon=QMessageBox.Information)
                                                     
                    returned_msg_outs = self.yn_msgbox(txt5=f"Do you wish to delete '{re_video_name_1}' audio ?",title5="Audio Delete - Yes/No",msg_icon=QMessageBox.Question)

                    if returned_msg_outs == QMessageBox.No:
                        pass
                    elif returned_msg_outs == QMessageBox.Yes:
                        os.remove(source_mp3_1)

                        self.msg_autoClose(msg_text=f"Successfully deleted '{re_video_name_1}' audio.",msg_title="Audio Delete - Success",close_tmr=3,msg_icon=QMessageBox.Information)
                
                elif os.path.exists(source_mp3_2) == True:

                    self.link_input.clear()

                    self.res_combobox.setCurrentText("720p")

                    self.msg_autoClose(msg_text=f"'{re_video_name_1}' audio already exists in {audios_folder_name}.",msg_title="YouTube saver Notify - Audio exists",close_tmr=3,msg_icon=QMessageBox.Information)
                                                     
                    returned_msg_outs = self.yn_msgbox(txt5=f"Do you wish to delete '{re_video_name_2}' audio ?",title5="Audio Delete - Yes/No",msg_icon=QMessageBox.Question)

                    if returned_msg_outs == QMessageBox.No:
                        pass
                    elif returned_msg_outs == QMessageBox.Yes:
                        os.remove(source_mp3_2)

                        self.msg_autoClose(msg_text=f"Successfully deleted '{re_video_name_2}' audio.",msg_title="Audio Delete - Success",close_tmr=3,msg_icon=QMessageBox.Information)
                else:

                    self.msg_autoClose(msg_text=f"Started to download audio.",msg_title="YouTube saver Notify - Audio Download Started",close_tmr=3,msg_icon=QMessageBox.Information)
                                                    
                    # Convert downloaded audio mp4 as audio      
                    returned_aud_name = self.pytube_moviepy_audio_dwnld(yt_attrib7=yt,res7=res3,path7=path3,
                    audio_format7=audio_format,video_format7=video_format,
                    yt_video_author7=video_author,yt_video_published_year7=video_published_year,ytvid_id7=video_id)

                    if returned_aud_name != None:

                        self.msg_autoClose(msg_text=f"'{returned_aud_name}' audio has been successfully downloaded in '{audios_folder_name}' folder.",msg_title="Audio Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)

                        if url3=="" and self.res_combobox.currentText()=="720p":
                                    
                            pass
                                                
                        else:

                            self.delay(1.76)

                            returned_msg_outs = self.yn_msgbox(txt5="Do you wish to download another audio from YouTube ?",title5="Yes/No",msg_icon=QMessageBox.Question)

                            if returned_msg_outs == QMessageBox.No:
                                pass
                            elif returned_msg_outs == QMessageBox.Yes:
                                self.link_input.clear()

                                self.res_combobox.setCurrentText("720p")

                                self.msg_autoClose(msg_text="All values reseted.",msg_title="Notify - Reset Done",close_tmr=3,msg_icon=QMessageBox.Information)
                            else:
                                pass
                    else:

                        self.msg_autoClose(msg_text=f"All download attempts failed.",msg_title="Audio Download - Failed.",close_tmr=3,msg_icon=QMessageBox.Close)
            else:
                self.link_input.clear()

                self.res_combobox.setCurrentText("720p")
                
                self.msg_autoClose(msg_text="Oops! Sorry, could not download audio due to age restriction.",msg_title="Audio download failed - Age restriction detected",close_tmr=3,msg_icon=QMessageBox.Information)
        except pytube.exceptions.ExtractError as py_yt_extractErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=(py_yt_extractErr),err_msgtitle="YouTube Saver - Extraction error:",err_msgtxt=f"Oops! couldn't extract data from link the '{url3}'.")
            
        except pytube.exceptions.HTMLParseError as py_yt_htmlErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_htmlErr),err_msgtitle="YouTube Saver - HTML parser error:",err_msgtxt=f"Oops! Sorry couldn't parse HTML form the link '{url3}'.")

            
        except pytube.exceptions.LiveStreamError as py_yt_liveStreamErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_liveStreamErr),err_msgtitle="YouTube saver - Live stream error:",err_msgtxt=f"Oops! couldn't download a live video stream from the link '{url3}'.")

        except pytube.exceptions.MaxRetriesExceeded as py_yt_maxLmtErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")
            
            self.apps_log_sys(logerr_msg=str(py_yt_maxLmtErr),err_msgtitle="YouTube saver - Maximum retries error:",err_msgtxt="Oops! Sorry retries exceeded maximum limit.")

        except pytube.exceptions.MembersOnly as py_yt_membersOnlyErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_membersOnlyErr),err_msgtitle="YouTube saver - Members only error:",err_msgtxt="Sorry, looks like the video can be acesses by members only.")

        except pytube.exceptions.RecordingUnavailable as py_yt_RecordingUnavailableErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_RecordingUnavailableErr),err_msgtitle="YouTube saver - Video recoding Unavailable error:",err_msgtxt="Looks like the video has no recording functionalties.")
 
        except pytube.exceptions.VideoPrivate as py_yt_VideoPrivateErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoPrivateErr),err_msgtitle="YouTube saver - Video private error:",err_msgtxt="The video is set to private by the owner.")
            
        except pytube.exceptions.VideoRegionBlocked as py_yt_VideoRegionBlockedErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoRegionBlockedErr),err_msgtitle="YouTube saver - Video regional error:",err_msgtxt="Seems like the video is blocked at your country or current region.")
                                   
        except pytube.exceptions.VideoUnavailable as py_yt_VideoUnavailableErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoUnavailableErr),err_msgtitle="YouTube saver - Video unavailable error:",err_msgtxt="Seems like the video is not available.")

        except AttributeError as yt_AttErr:

            #print(str(yt_AttErr))

            self.apps_log_sys(logerr_msg=str(yt_AttErr),err_msgtitle="YouTube saver - Attribute error:",err_msgtxt=str(yt_AttErr))

        except pytube.exceptions.PytubeError as yt_req_err:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(yt_req_err),err_msgtitle="YouTube saver - Request error:",err_msgtxt=str(yt_req_err))
 
        except FileNotFoundError as yt_files_unexists_err:

            # delete source mp4 file
            try:
                os.remove(source_mp4_1)
            except OSError:
                pass

            try:
                os.remove(source_mp4_2)
            except OSError:
                pass

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(yt_files_unexists_err),err_msgtitle="YouTube saver - Video download error:",err_msgtxt=str(yt_files_unexists_err))

        except Exception as yt_err:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(yt_err),err_msgtitle="YouTube saver - error:",err_msgtxt=str(yt_err))

            """ 
            if "MoviePy error:" in str(yt_err):
                self.msg_autoClose(msg_text="Audio conversion failed... Seeking alternative.",msg_title="Notify",close_tmr=3,msg_icon=QMessageBox.Information)

                file_lsts = os.listdir(path3)

                for file in file_lsts:

                    vfl_name , vfl_extnts = os.path.splitext(file)

                    non_mp3fl_path = os.path.join(path3,file)

                    mp3fl_path = non_mp3fl_path.replace(vfl_extnts,".mp3")
 
                    clip = VideoFileClip(non_mp3fl_path)
                    clip.audio.write_audiofile(mp3fl_path)
                    clip.close()

                    # Set audio file propties
                    f2 = music_tag.load_file(mp3fl_path)
                    f2['title'] = vfl_name
                    f2['year']  = video_published_year
                    f2['artist']= video_author
                    f2.save()

                    # delete source mp4 file
                    try:
                        os.remove(non_mp3fl_path)
                    except OSError:
                        pass

                    self.msg_autoClose(msg_text="Audio conversion has been successful.",msg_title="Audio Conversion - Success",close_tmr=3,msg_icon=QMessageBox.Information)
            else:
                pass 

            """
    
    def yt_playlist_aud(self,res4,url4,path4):

        try:

            yt_playlist_infos = pytube.Playlist(url4)

            playlist_URLS = yt_playlist_infos.video_urls

            playlist_title = yt_playlist_infos.title

            playlist_title_re = playlist_title.replace("'"," ").replace(":"," ").replace("'"," ").replace("|"," ").replace("/"," ").replace("\\"," ").replace("<"," ").replace(">"," ").replace("*"," ").replace("?"," ")

            playlist_audios_title_sub_folder = os.path.join(path4,playlist_title_re)

                            
            try:

                os.makedirs(playlist_audios_title_sub_folder)
                            
            except OSError:

                pass

            yt_cj_modes = ['Selective (Picky choices)','Complete (Full set)']

            returned_lstsbox_gui_out , returned_lstsbox_item_out = self.lists_box(l2=yt_cj_modes,title2="YouTube Saver - 'Candy jar'",txt2="Choose your 'Candy' mode")

            if returned_lstsbox_gui_out == wx.ID_OK:

                if "Selective" in returned_lstsbox_item_out:

                    while True:

                        n1_in = QInputDialog(self)
                        n1_in.setWindowTitle("First order of YouTube playlist audio:")
                        n1_in.setLabelText(f"Enter first order of the audio in YouTube playlist '{playlist_title}'.")
                        n1_in.setTextEchoMode(QLineEdit.Password)
                            
                        n1_in.setFixedSize(400, 240)

                        n1_in.setStyleSheet(
                                """
                                
                                QLabel{
                                    font-size:20px;
                                        
                                    font-family:Arial;
                                    }
                                    
                                QLineEdit{
                                    font-size:20px;
                                    font-family:Arial;
                                    }
                                    
                                QPushButton{
                                    font-size:20px;                         
                                    }
                                """
                                    )
                        okPressed_n1 = n1_in.exec_()
                        n1_txt = n1_in.textValue()

                        if okPressed_n1==True and n1_txt != '':

                            try:
                                playlist_n1 = int(n1_txt)-1
                                                
                                break
                            except ValueError:
                                #pass
   
                                self.msg_autoClose(msg_text="Please enter the number (eg: 0 or 1).",msg_title="Input invalid:",close_tmr=3,msg_icon=QMessageBox.Critical)
                        else:

                            self.msg_autoClose(msg_text="Null value not accepted. So please enter the number.",msg_title="Null error:",close_tmr=3,msg_icon=QMessageBox.Information)

    
                    while True:

                        n2_in = QInputDialog(self)
                        n2_in.setWindowTitle("Second order of YouTube playlist audio:")
                        n2_in.setLabelText(f"Enter second order of the audio in YouTube playlist '{playlist_title}'.") 
                        n2_in.setTextEchoMode(QLineEdit.Password)
                            
                        n2_in.setFixedSize(400, 240)

                        n2_in.setStyleSheet(
                                """
                                
                                QLabel{
                                    font-size:20px;
                                        
                                    font-family:Arial;
                                    }
                                    
                                QLineEdit{
                                    font-size:20px;
                                    font-family:Arial;
                                    }
                                    
                                QPushButton{
                                    font-size:20px;                         
                                    }
                                """
                                    )
                        okPressed_n2 = n2_in.exec_()
                        n2_txt = n2_in.textValue()

                        if okPressed_n2==True and n2_txt != '':

                            try:
                                playlist_n2 = int(n2_txt)
                                                
                                break
                            except ValueError:
                                #pass
   
                                self.msg_autoClose(msg_text="Please enter the number (eg: 0 or 1).",msg_title="Input invalid:",close_tmr=3,msg_icon=QMessageBox.Critical)
                        else:

                            self.msg_autoClose(msg_text="Null value not accepted. So please enter the number.",msg_title="Null error:",close_tmr=3,msg_icon=QMessageBox.Information)
    

                    for yt_video_url in yt_playlist_infos.video_urls[playlist_n1:playlist_n2]:
                        try:

                            yt = pytube.YouTube(yt_video_url)

                            video_name = yt.title

                            video_id = yt.video_id

                            video_published_year = yt.publish_date.year

                            video_author= yt.author

                            video_format = "mp4"

                            audio_format = "mp3"

                            re_video_name_1 = video_name.replace('"','').replace(":","").replace("'","").replace("|","").replace("/","").replace("\\","").replace("<","").replace(">","").replace("*","").replace("?","")
                                            
                            src_video_file_1 = f"{re_video_name_1}_{video_id}.{video_format}"

                            # src_audio_file_1 = "{0}-{1}.{2}".format(re_video_name_1,video_id,audio_format)
 
                            yt_src_audio_file_1 = f"{re_video_name_1}_{video_id}.{audio_format}"

                            source_mp4_1 = os.path.join(path4,src_video_file_1)

                            source_mp3_1 = os.path.join(playlist_audios_title_sub_folder,yt_src_audio_file_1)
                            
                            re_video_name_2 = video_name.replace('"',' ').replace(":"," ").replace("'"," ").replace("|"," ").replace("/"," ").replace("\\"," ").replace("<"," ").replace(">"," ").replace("*"," ").replace("?"," ")
                                                            
                            src_video_file_2 = f"{re_video_name_2}_{video_id}.{video_format}"

                            # src_audio_file_2 = "{0}-{1}.{2}".format(re_video_name_2,video_id,audio_format)

                            yt_src_audio_file_2 = f"{re_video_name_2}_{video_id}.{audio_format}"

                            source_mp4_2 = os.path.join(playlist_audios_title_sub_folder,src_video_file_2)

                            source_mp3_2 = os.path.join(playlist_audios_title_sub_folder,yt_src_audio_file_2)

                            # source_mp3_id = os.path.join(path3,src_audio_file_2)

                            yt_age_restricted = yt.age_restricted

                            if yt_age_restricted == False:

                                if  os.path.exists(source_mp3_1) == True:

                                    self.link_input.clear()

                                    self.res_combobox.setCurrentText("720p")

                                    self.msg_autoClose(msg_text=f"'{re_video_name_1}' audio already exists in '{playlist_title_re}' audio playlist folder.",msg_title="YouTube saver Notify - Audio exists",close_tmr=3,msg_icon=QMessageBox.Information)
                                elif  os.path.exists(source_mp3_2) == True:

                                    self.link_input.clear()

                                    self.res_combobox.setCurrentText("720p")

                                    self.msg_autoClose(msg_text=f"'{re_video_name_2}' audio already exists in '{playlist_title_re}' audio playlist folder.",msg_title="YouTube saver Notify - Audio exists",close_tmr=3,msg_icon=QMessageBox.Information)

                                else:

                                    self.msg_autoClose(msg_text="Started to download audio.",msg_title="YouTube saver Notify - Audio Download Started",close_tmr=3,msg_icon=QMessageBox.Information)
                                                                    
                                    # Convert downloaded audio mp4 as audio      
                                    returned_aud_name = self.pytube_moviepy_audio_dwnld(yt_attrib7=yt,res7=res4,path7=playlist_audios_title_sub_folder,
                                    audio_format7=audio_format,video_format7=video_format,
                                    yt_video_author7=video_author,yt_video_published_year7=video_published_year,ytvid_id7=video_id)

                                    if returned_aud_name != None:
                                        self.msg_autoClose(msg_text=f"'{returned_aud_name}' audio has been successfully downloaded in '{playlist_title_re}' audio playlist folder.",msg_title="Audio Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)
                                    else:
                                        self.msg_autoClose(msg_text=f"All download attempts failed.",msg_title="Audio Download - Failed.",close_tmr=3,msg_icon=QMessageBox.Close)
                            else:
                                self.msg_autoClose(msg_text="Oops! Sorry, could not download audio due to age restriction.",msg_title="Audio download failed - Age restriction detected",close_tmr=3,msg_icon=QMessageBox.Information)
                        except pytube.exceptions.ExtractError as py_yt_extractErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=(py_yt_extractErr),err_msgtitle="YouTube Saver - Extraction error:",err_msgtxt=f"Oops! couldn't extract data from link the '{url4}'.")
                            
                        except pytube.exceptions.HTMLParseError as py_yt_htmlErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_htmlErr),err_msgtitle="YouTube Saver - HTML parser error:",err_msgtxt=f"Oops! Sorry couldn't parse HTML form the link '{url4}'.")

                            
                        except pytube.exceptions.LiveStreamError as py_yt_liveStreamErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_liveStreamErr),err_msgtitle="YouTube saver - Live stream error:",err_msgtxt=f"Oops! couldn't download a live video stream from the link '{url4}'.")

                        except pytube.exceptions.MaxRetriesExceeded as py_yt_maxLmtErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")
                            
                            self.apps_log_sys(logerr_msg=str(py_yt_maxLmtErr),err_msgtitle="YouTube saver - Maximum retries error:",err_msgtxt="Oops! Sorry retries exceeded maximum limit.")

                        except pytube.exceptions.MembersOnly as py_yt_membersOnlyErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_membersOnlyErr),err_msgtitle="YouTube saver - Members only error:",err_msgtxt="Sorry, looks like the video can be acesses by members only.")

                        except pytube.exceptions.RecordingUnavailable as py_yt_RecordingUnavailableErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_RecordingUnavailableErr),err_msgtitle="YouTube saver - Video recoding Unavailable error:",err_msgtxt="Looks like the video has no recording functionalties.")
                
                        except pytube.exceptions.VideoPrivate as py_yt_VideoPrivateErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoPrivateErr),err_msgtitle="YouTube saver - Video private error:",err_msgtxt="The video is set to private by the owner.")
                            
                        except pytube.exceptions.VideoRegionBlocked as py_yt_VideoRegionBlockedErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoRegionBlockedErr),err_msgtitle="YouTube saver - Video regional error:",err_msgtxt="Seems like the video is blocked at your country or current region.")
                                                
                        except pytube.exceptions.VideoUnavailable as py_yt_VideoUnavailableErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoUnavailableErr),err_msgtitle="YouTube saver - Video unavailable error:",err_msgtxt="Seems like the video is not available.")

                        except AttributeError as yt_AttErr:

                            #print(str(yt_AttErr))

                            self.apps_log_sys(logerr_msg=str(yt_AttErr),err_msgtitle="YouTube saver - Attribute error:",err_msgtxt=str(yt_AttErr))

                        except pytube.exceptions.PytubeError as yt_req_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_req_err),err_msgtitle="YouTube saver - Request error:",err_msgtxt=str(yt_req_err))
                
                        except FileNotFoundError as yt_files_unexists_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_files_unexists_err),err_msgtitle="YouTube saver - Video download error:",err_msgtxt=str(yt_files_unexists_err))

                        except Exception as yt_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_err),err_msgtitle="YouTube saver - error:",err_msgtxt=str(yt_err)) 

                            """
                            if "MoviePy error:" in str(yt_err):
                                self.msg_autoClose(msg_text="Audio conversion failed... Seeking alternative.",msg_title="Notify",close_tmr=3,msg_icon=QMessageBox.Information)

                                file_lsts = os.listdir(path4)

                                for file in file_lsts:

                                    vfl_name , vfl_extnts = os.path.splitext(file)

                                    non_mp3fl_path = os.path.join(path4,file)

                                    mp3fl_path = non_mp3fl_path.replace(vfl_extnts,".mp3")

                                    clip = VideoFileClip(non_mp3fl_path)
                                    clip.audio.write_audiofile(mp3fl_path)
                                    clip.close()

                                    # Set audio file propties
                                    f4 = music_tag.load_file(mp3fl_path)
                                    f4['title'] = vfl_name
                                    f4['year']  = video_published_year
                                    f4['artist']= video_author
                                    f4.save()

                                    # delete source mp4 file
                                    try:
                                        os.remove(non_mp3fl_path)
                                    except OSError:
                                        pass

                                    self.msg_autoClose(msg_text="Audio conversion has been successful.",msg_title="Audio Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)

                            else:
                                pass 
                            
                            """
                
                    
                    self.msg_autoClose(msg_text=f"Selected audios has been successfully downloaded in '{playlist_title_re}' folder.",msg_title="Playlists Audios Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)
        
                    if url4=="":
                                    
                        pass
                                                
                    else:

                        self.delay(1.76)

                        returned_msg_outs = self.yn_msgbox(txt5="Do you wish to download another video from YouTube ?",title5="Yes/No",msg_icon=QMessageBox.Question)

                        if returned_msg_outs == QMessageBox.No:
                            pass
                        elif returned_msg_outs == QMessageBox.Yes:
                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.msg_autoClose(msg_text="All values reseted.",msg_title="Notify - Reset Done",close_tmr=3,msg_icon=QMessageBox.Information)
                        else:
                            pass
 
                else:

                    playlist_video_n = len(playlist_URLS)

                    for yt_video_url in yt_playlist_infos.video_urls[0:playlist_video_n]:

                        try:

                            yt = pytube.YouTube(yt_video_url)

                            video_name = yt.title

                            video_id = yt.video_id

                            video_format = "mp4"

                            audio_format = "mp3"

                            re_video_name_1 = video_name.replace('"','').replace(":","").replace("'","").replace("|","").replace("/","").replace("\\","").replace("<","").replace(">","").replace("*","").replace("?","")
                                            
                            src_video_file_1 = f"{re_video_name_1}_{video_id}.{video_format}"

                            # src_audio_file_1 = "{0}-{1}.{2}".format(re_video_name_1,video_id,audio_format)

                            yt_src_audio_file_1 = f"{re_video_name_1}_{video_id}.{audio_format}"

                            source_mp4_1 = os.path.join(playlist_audios_title_sub_folder,src_video_file_1)

                            source_mp3_1 = os.path.join(playlist_audios_title_sub_folder,yt_src_audio_file_1)
                            
                            re_video_name_2 = video_name.replace('"',' ').replace(":"," ").replace("'"," ").replace("|"," ").replace("/"," ").replace("\\"," ").replace("<"," ").replace(">"," ").replace("*"," ").replace("?"," ")
                                                            
                            src_video_file_2 = f"{re_video_name_2}_{video_id}.{video_format}"

                            # src_audio_file_2 = "{0}-{1}.{2}".format(re_video_name_2,video_id,audio_format)

                            yt_src_audio_file_2 = f"{re_video_name_1}_{video_id}.{audio_format}"

                            source_mp4_2 = os.path.join(playlist_audios_title_sub_folder,src_video_file_2)

                            source_mp3_2 = os.path.join(playlist_audios_title_sub_folder,yt_src_audio_file_2)

                            yt_age_restricted = yt.age_restricted

                            if yt_age_restricted == False:

                                if os.path.exists(source_mp3_1) is True:

                                    self.link_input.clear()

                                    self.res_combobox.setCurrentText("720p")

                                    self.msg_autoClose(msg_text=f"'{re_video_name_1}' audio already exists in '{playlist_title_re}' audio playlist folder.",msg_title="YouTube saver Notify - Audio exists",close_tmr=3,msg_icon=QMessageBox.Information)

                                elif  os.path.exists(source_mp3_2) == True:

                                    self.link_input.clear()

                                    self.res_combobox.setCurrentText("720p")

                                    self.msg_autoClose(msg_text=f"'{re_video_name_2}' audio already exists in '{playlist_title_re}' audio playlist folder.",msg_title="YouTube saver Notify - Audio exists",close_tmr=3,msg_icon=QMessageBox.Information)                               
                                
                                else:

                                    self.msg_autoClose(msg_text="Started to download audio.",msg_title="YouTube saver Notify - Audio Download Started",close_tmr=3,msg_icon=QMessageBox.Information)

                                    # Convert downloaded audio mp4 as audio                       
                                    returned_aud_name = self.pytube_moviepy_audio_dwnld(yt_attrib7=yt,res7=res4,path7=playlist_audios_title_sub_folder,
                                    audio_format7=audio_format,video_format7=video_format,
                                    yt_video_author7=video_author,yt_video_published_year7=video_published_year,ytvid_id7=video_id)


                                    if returned_aud_name != None:
                                        self.msg_autoClose(msg_text=f"'{returned_aud_name}' audio has been successfully downloaded in '{playlist_title_re}' audio playlist folder.",msg_title="Audio Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)
                                    else:

                                        self.msg_autoClose(msg_text=f"All download attempts failed.",msg_title="Audio Download - Failed.",close_tmr=3,msg_icon=QMessageBox.Close)
                            else:
                                self.msg_autoClose(msg_text="Oops! Sorry, could not download audio due to age restriction.",msg_title="Audio download failed - Age restriction detected",close_tmr=3,msg_icon=QMessageBox.Information)
                        except pytube.exceptions.ExtractError as py_yt_extractErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=(py_yt_extractErr),err_msgtitle="YouTube Saver - Extraction error:",err_msgtxt=f"Oops! couldn't extract data from link the '{url4}'.")
                            
                        except pytube.exceptions.HTMLParseError as py_yt_htmlErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_htmlErr),err_msgtitle="YouTube Saver - HTML parser error:",err_msgtxt=f"Oops! Sorry couldn't parse HTML form the link '{url4}'.")

                            
                        except pytube.exceptions.LiveStreamError as py_yt_liveStreamErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_liveStreamErr),err_msgtitle="YouTube saver - Live stream error:",err_msgtxt=f"Oops! couldn't download a live video stream from the link '{url4}'.")

                        except pytube.exceptions.MaxRetriesExceeded as py_yt_maxLmtErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")
                            
                            self.apps_log_sys(logerr_msg=str(py_yt_maxLmtErr),err_msgtitle="YouTube saver - Maximum retries error:",err_msgtxt="Oops! Sorry retries exceeded maximum limit.")

                        except pytube.exceptions.MembersOnly as py_yt_membersOnlyErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_membersOnlyErr),err_msgtitle="YouTube saver - Members only error:",err_msgtxt="Sorry, looks like the video can be acesses by members only.")

                        except pytube.exceptions.RecordingUnavailable as py_yt_RecordingUnavailableErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_RecordingUnavailableErr),err_msgtitle="YouTube saver - Video recoding Unavailable error:",err_msgtxt="Looks like the video has no recording functionalties.")
                
                        except pytube.exceptions.VideoPrivate as py_yt_VideoPrivateErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoPrivateErr),err_msgtitle="YouTube saver - Video private error:",err_msgtxt="The video is set to private by the owner.")
                            
                        except pytube.exceptions.VideoRegionBlocked as py_yt_VideoRegionBlockedErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoRegionBlockedErr),err_msgtitle="YouTube saver - Video regional error:",err_msgtxt="Seems like the video is blocked at your country or current region.")
                                                
                        except pytube.exceptions.VideoUnavailable as py_yt_VideoUnavailableErr:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(py_yt_VideoUnavailableErr),err_msgtitle="YouTube saver - Video unavailable error:",err_msgtxt="Seems like the video is not available.")

                        except AttributeError as yt_AttErr:

                            #print(str(yt_AttErr))

                            self.apps_log_sys(logerr_msg=str(yt_AttErr),err_msgtitle="YouTube saver - Attribute error:",err_msgtxt=str(yt_AttErr))

                        except pytube.exceptions.PytubeError as yt_req_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_req_err),err_msgtitle="YouTube saver - Request error:",err_msgtxt=str(yt_req_err))
                
                        except FileNotFoundError as yt_files_unexists_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_files_unexists_err),err_msgtitle="YouTube saver - Video download error:",err_msgtxt=str(yt_files_unexists_err))

                        except Exception as yt_err:

                            self.link_input.clear()

                            self.res_combobox.setCurrentText("720p")

                            self.apps_log_sys(logerr_msg=str(yt_err),err_msgtitle="YouTube saver - error:",err_msgtxt=str(yt_err)) 

                            """
                            if "MoviePy error:" in str(yt_err):
                                self.msg_autoClose(msg_text="Audio conversion failed... Seeking alternative.",msg_title="Notify",close_tmr=3,msg_icon=QMessageBox.Information)

                                file_lsts = os.listdir(path4)

                                for file in file_lsts:

                                    vfl_name , vfl_extnts = os.path.splitext(file)

                                    non_mp3fl_path = os.path.join(path4,file)

                                    mp3fl_path = non_mp3fl_path.replace(vfl_extnts,".mp3")

                                    clip = VideoFileClip(non_mp3fl_path)
                                    clip.audio.write_audiofile(mp3fl_path)
                                    clip.close()

                                    # Set audio file propties
                                    f6 = music_tag.load_file(mp3fl_path)
                                    f6['title'] = vfl_name
                                    f6['year']  = video_published_year
                                    f6['artist']= video_author
                                    f6.save()

                                    # delete source mp4 file
                                    try:
                                        os.remove(non_mp3fl_path)
                                    except OSError:
                                        pass

                                    self.msg_autoClose(msg_text="Audio conversion has been successful.",msg_title="Audio Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)

                            else:
                                pass     

                            """      

                    if (len(os.listdir(path4))==len(yt_playlist_infos.video_urls)):                         
                        self.msg_autoClose(msg_text=f"All audios has been successfully downloaded in '{playlist_title_re}' folder.",msg_title="Playlists Audios Download - Success",close_tmr=3,msg_icon=QMessageBox.Information)
            
                        if url4=="":
                                        
                            pass
                                                    
                        else:

                            self.delay(1.76)

                            returned_msg_outs = self.yn_msgbox(txt5="Do you wish to download another video from YouTube ?",title5="Yes/No",msg_icon=QMessageBox.Question)

                            if returned_msg_outs == QMessageBox.No:
                                pass
                            elif returned_msg_outs == QMessageBox.Yes:
                                self.link_input.clear()

                                self.res_combobox.setCurrentText("720p")

                                self.msg_autoClose(msg_text="All values reseted.",msg_title="Notify - Reset Done",close_tmr=3,msg_icon=QMessageBox.Information)
                            else:
                                pass
                    else:
                        pass
                
        except pytube.exceptions.ExtractError as py_yt_extractErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=(py_yt_extractErr),err_msgtitle="YouTube Saver - Extraction error:",err_msgtxt=f"Oops! couldn't extract playlist data from link the '{url4}'.")
            
        except pytube.exceptions.HTMLParseError as py_yt_htmlErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_htmlErr),err_msgtitle="YouTube Saver - HTML parser error:",err_msgtxt=f"Oops! Sorry couldn't parse HTML form the playlist link '{url4}'.")
   
        except pytube.exceptions.LiveStreamError as py_yt_liveStreamErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_liveStreamErr),err_msgtitle="YouTube saver - Live stream error:",err_msgtxt=f"Oops! couldn't download playlist stream stream from the link '{url4}'.")

        except pytube.exceptions.MaxRetriesExceeded as py_yt_maxLmtErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")
            
            self.apps_log_sys(logerr_msg=str(py_yt_maxLmtErr),err_msgtitle="YouTube saver - Maximum retries error:",err_msgtxt="Oops! Sorry retries exceeded maximum limit.")

        except pytube.exceptions.MembersOnly as py_yt_membersOnlyErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_membersOnlyErr),err_msgtitle="YouTube saver - Members only error:",err_msgtxt="Sorry, looks like the playlist can be acesses by members only.")

        except pytube.exceptions.RecordingUnavailable as py_yt_RecordingUnavailableErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_RecordingUnavailableErr),err_msgtitle="YouTube saver - Video recoding Unavailable error:",err_msgtxt="Looks like the playlist has no recording functionalties.")
 
        except pytube.exceptions.VideoPrivate as py_yt_VideoPrivateErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoPrivateErr),err_msgtitle="YouTube saver - Playlist private error:",err_msgtxt="The playlists is set to private by the owner.")
            
        except pytube.exceptions.VideoRegionBlocked as py_yt_VideoRegionBlockedErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoRegionBlockedErr),err_msgtitle="YouTube saver - Playlist regional error:",err_msgtxt="Seems like the playlist is blocked at your country or current region.")
                                   
        except pytube.exceptions.VideoUnavailable as py_yt_VideoUnavailableErr:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(py_yt_VideoUnavailableErr),err_msgtitle="YouTube saver - Playlist unavailable error:",err_msgtxt="Seems like the playlist is not available.")

        except AttributeError as yt_AttErr:

            #print(str(yt_AttErr))

            self.apps_log_sys(logerr_msg=str(yt_AttErr),err_msgtitle="YouTube saver - Attribute error:",err_msgtxt=str(yt_AttErr))

        except pytube.exceptions.PytubeError as yt_req_err:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(yt_req_err),err_msgtitle="YouTube saver - Request error:",err_msgtxt=str(yt_req_err))
 
        except Exception as yt_err:

            self.link_input.clear()

            self.res_combobox.setCurrentText("720p")

            self.apps_log_sys(logerr_msg=str(yt_err),err_msgtitle="YouTube saver - error:",err_msgtxt=str(yt_err))
    
    def pytube_video_dwnld(self,path6,yt_attrib6,res6,ytvid_id6):
        for n6 in range(1,5,1):

            if n6 < 5:
                video = yt_attrib6.streams.filter(res=res6).first()

                yt_video_file_size = format(yt_attrib6.streams.get_by_resolution(res6).filesize/(1048576),'.2f')

                yt_video_dl6 = video.download(path6)

                yt_video_dl_file_size = format(os.path.getsize(yt_video_dl6)/1048576,'.2f')

                # print(f"\n_> YouTube video file size (yt_video_file_size):\n {yt_video_file_size}")

                # print(f"\n_> YouTube video file size (os.path.getsize):\n {yt_video_dl_file_size}")

                if yt_video_dl_file_size==yt_video_file_size:
                    break
                else:
                    pass

            else:
                self.msg_autoClose(msg_text=f"Attemp Number: {str(n6)} failed. Trying again....",msg_title="Notify - Trying again",close_tmr=3,msg_icon=QMessageBox.Critical)


        # Convert video into audio if exists
        if os.path.exists(yt_video_dl6)==True:

            # Get downloaded youtube video name
            yt_video_dl_name6, yt_video_dl_type6 = os.path.splitext(os.path.basename(yt_video_dl6))

            # Video name with watch ID
            yt_vidfl_id6 = f"{yt_video_dl_name6}_{ytvid_id6}"

            yt_video_dl_name_replaced6 = yt_video_dl6.replace(yt_video_dl_name6,yt_vidfl_id6)

            os.rename(yt_video_dl6,yt_video_dl_name_replaced6)

            yt_video_dl_renamed6, yt_video_dl_rename_type6 = os.path.splitext(os.path.basename(yt_video_dl_name_replaced6))

            return yt_video_dl_renamed6

        else:
            return None

    def pytube_moviepy_audio_dwnld(self,path7,yt_attrib7,res7,video_format7,audio_format7,yt_video_published_year7,yt_video_author7,ytvid_id7):
        for n7 in range(1,5,1):

            if n7 < 5 :
                video = yt_attrib7.streams.filter(res=res7).first()

                yt_video_file_size = format(yt_attrib7.streams.get_by_resolution(res7).filesize/(1024*1024),'.2f')

                yt_video_dl7 = video.download(path7)

                yt_video_dl_file_size = format(os.path.getsize(yt_video_dl7)/1048576,'.2f')

                # print(f"\n_> YouTube video file size (yt_video_file_size):\n {yt_video_file_size}")

                # print(f"\n_> YouTube video file size (os.path.getsize):\n {yt_video_dl_file_size}")

                self.delay(1.18)

                if yt_video_dl_file_size==yt_video_file_size:
                    break
                else:
                    pass
            else:
                # pass
                self.msg_autoClose(msg_text=f"Attemp Number: {str(n7)} failed. Trying again....",msg_title="Notify - Trying again",close_tmr=3,msg_icon=QMessageBox.Critical)

        # Convert video into audio if exists
        if os.path.exists(yt_video_dl7)==True:

            # Get downloaded video name
            yt_video_dl_name7, yt_video_dl_type7 = os.path.splitext(os.path.basename(yt_video_dl7))

            # Video name with watch ID
            yt_vid_name_id7 = f"{yt_video_dl_name7}_{ytvid_id7}"

            # yt_video_dl_name_replaced7 = str(yt_video_dl7).replace(yt_video_dl_name7,yt_vid_name_id7)

            # os.rename(yt_video_dl7,yt_video_dl_name_replaced7)

            # yt_video_dl_renamed, yt_video_dl_rename_type = os.path.splitext(os.path.basename(yt_video_dl_name_replaced))

            # source_mp3_path7 = str(yt_video_dl7).replace(video_format7, audio_format7)

            # Final mp3 file
            final_mp3_fl7 = f"{yt_vid_name_id7}.{audio_format7}"
            final_mp3_path7 = os.path.join(os.path.dirname(yt_video_dl7),final_mp3_fl7)

            # Convert video into audio
            my_clip7 = VideoFileClip(yt_video_dl7)
            my_clip7.audio.write_audiofile(final_mp3_path7)
            my_clip7.close()

            yt_audio_name7 , yt_audio_type7 = os.path.splitext(os.path.basename(final_mp3_path7))

            # Set audio file properties
            f1 = music_tag.load_file(final_mp3_path7)
            f1['title'] = yt_audio_name7
            f1['year']  = yt_video_published_year7
            f1['artist']= yt_video_author7
            f1.save()

            # Delete video
            try:
                os.remove(yt_video_dl7)
            except OSError:
                pass 

            return yt_audio_name7
        else:
            return None
    
    def yn_msgbox(self,txt5,title5,msg_icon):

        # returned_icofl_path = self.icon_fls()

        # print(returned_icofl_path)

        yn_msg = QMessageBox()

        yn_msg.setIcon(msg_icon)

        yn_msg.setIcon(QMessageBox.Warning)

        yn_msg.setText(txt5)
      
        yn_msg.setWindowTitle(title5)
              
        yn_msg.setStandardButtons(QMessageBox.Yes | QMessageBox.No)

        msg_button_out = yn_msg.exec()

        return msg_button_out

    def exit(self):
 
        returned_msg_outs = self.yn_msgbox(txt5="Are you sure you want to exit the app?",title5="Exit -Yes/No:",msg_icon=QMessageBox.Warning)

        if returned_msg_outs == QMessageBox.No:
            pass
        elif returned_msg_outs == QMessageBox.Yes:
            # app = QtWidgets.QApplication(sys.argv)
            # sys.exit(app.exec_())
            sys.exit()
        else:
            pass

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
